// cull.compute
// Culling Compute Shader
const char *cull_computeShader =
    "#version 450 core\n"
    "layout(local_size_x = 64) in; // Workgroup size\n"
    "\n"
    "struct InstanceData {\n"
    "    vec3 position;\n"
    "    vec4 rotation;\n"
    "    vec3 scale;\n"
    "    int modelIndex;\n"
    "};\n"
    "\n"
    "struct DrawArraysIndirectCommand {\n"
    "    uint count;\n"
    "    uint instanceCount;\n"
    "    uint first;\n"
    "    uint baseInstance;\n"
    "};\n"
    "\n"
    "layout(std430, binding = 1) buffer InstanceBuffer {\n"
    "    InstanceData instances[];\n"
    "};\n"
    "\n"
    "layout(std430, binding = 2) buffer ModelBoundsBuffer {\n"
    "    float modelRadius[];\n"
    "};\n"
    "\n"
    "layout(std430, binding = 3) buffer IndirectDrawBuffer {\n"
    "    DrawArraysIndirectCommand commands[];\n"
    "};\n"
    "\n"
    "layout(std430, binding = 4) buffer InstanceIDBuffer {\n"
    "    uint instanceIDs[];\n"
    "};\n"
    "\n"
    "layout(std430, binding = 5) buffer DrawCountBuffer {\n"
    "    uint drawCount;\n"
    "};\n"
    "\n"
    "uniform vec3 cameraPos;\n"
    "uniform float yawMin, yawMax, pitchMin, pitchMax;\n"
    "uniform uint vbo_offsets[3];\n"
    "uniform uint modelVertexCounts[3];\n"
    "\n"
    "void main() {\n"
    "    uint idx = gl_GlobalInvocationID.x;\n"
    "    if (idx >= 1) return; // INSTANCE_COUNT = 1\n"
    "    \n"
    "    InstanceData inst = instances[idx];\n"
    "    int modelIdx = inst.modelIndex;\n"
    "    \n"
    "    // Transform bounding sphere center to world space\n"
    "    vec3 center = inst.position;\n"
    "    float radius = modelRadius[modelIdx] * max(max(inst.scale.x, inst.scale.y), inst.scale.z);\n"
    "    \n"
    "    // Vector from camera to sphere center\n"
    "    vec3 toCenter = center - cameraPos;\n"
    "    float distance = length(toCenter);\n"
    "    if (distance < 0.001) return; // Avoid division by zero\n"
    "    \n"
    "    // Compute yaw and pitch\n"
    "    vec3 norm = toCenter / distance;\n"
    "    float yaw = atan(norm.z, norm.x); // atan2(z, x) for yaw\n"
    "    float pitch = asin(norm.y); // pitch = arcsin(y)\n"
    "    \n"
    "    // Check if sphere is within FOV (approximate, no angular radius adjustment)\n"
    "    bool visible = yaw >= yawMin && yaw <= yawMax && pitch >= pitchMin && pitch <= pitchMax;\n"
    "    if (!visible) return;\n"
    "    \n"
    "    // Append to draw command buffer\n"
    "    uint drawIdx = atomicAdd(drawCount, 1);\n"
    "    commands[drawIdx].count = modelVertexCounts[modelIdx];\n"
    "    commands[drawIdx].instanceCount = 1;\n"
    "    commands[drawIdx].first = vbo_offsets[modelIdx];\n"
    "    commands[drawIdx].baseInstance = idx;\n"
    "    instanceIDs[drawIdx] = idx;\n"
    "}\n";
