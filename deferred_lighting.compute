// deferred_lighting.compute
// Compute shader for processing 
const char *deferredLighting_computeShader =
    "#version 450 core\n"

    "layout(local_size_x = 8, local_size_y = 8) in;\n"

    // G-buffer inputs
    "layout(rgba8,   binding = 0) uniform image2D inputImage;\n"
    "layout(rgba16f, binding = 1) uniform image2D inputNormals;\n"
    "layout(binding = 2) uniform sampler2D inputDepth;\n"
    "layout(rgba32f, binding = 3) uniform image2D inputWorldPos;\n"
    "layout(rgba32i, binding = 5) uniform iimage2D inputTexMaps;\n"

    // Light buffer
    "layout(std430, binding = 5) buffer LightBuffer {\n"
    "    float lights[];\n"
    "};\n"

    // Vertex buffers (one per model, bound as SSBOs)
    "layout(std430, binding = 6) buffer VertexBuffer0 { float vertices0[]; };\n"
    "layout(std430, binding = 7) buffer VertexBuffer1 { float vertices1[]; };\n"
    "layout(std430, binding = 8) buffer VertexBuffer2 { float vertices2[]; };\n"
    "layout(std430, binding = 9) buffer BoundsBuffer { float bounds[]; };\n"

    "struct Instance {\n"
    "    int modelIndex;\n"
    "    int texIndex;\n"
    "    int glowIndex;\n"
    "    int specIndex;\n"
    "    int normIndex;\n"
    "    float posx;\n"
    "    float posy;\n"
    "    float posz;\n"
    "    float sclx;\n"
    "    float scly;\n"
    "    float sclz;\n"
    "    float rotx;\n"
    "    float roty;\n"
    "    float rotz;\n"
    "    float rotw;\n"
    "};\n"

    "layout(std430, binding = 10) buffer InstancesBuffer {\n"
    "    Instance instances[];\n"
    "};\n"

    "layout(std430, binding = 11) buffer InstanceBuffer {\n"
    "    mat4 instanceMatrices[];\n"
    "};\n"

    "layout(std430, binding = 13) buffer BlueNoise {\n"
    "    float blueNoiseColors[];\n"
    "};\n"
    
    "struct VXGIVoxel {\n"
    "    vec3 direct_light;\n"
    "    vec3 indirect_light;\n"
    "    float occupancy;\n"
    "};\n"
    
    // The indices of the current lightSubset we are in for indexing into full
    // lights[LIGHT_COUNT * LIGHT_DATA_SIZE] buffer.
    "layout(std430, binding = 19) buffer LightIndices {\n"
    "    uint lightIndicesForSubset[64];\n"
    "};\n"
    
    "uniform int voxelCount;\n"

    // Uniforms from deferred shader
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"

    // Uniforms for ray tracing
    "uniform int shadowsEnabled;\n"
    "uniform int vxgiEnabled;\n"
    "uniform int debugView;\n"
    
    "uniform uint lightSubsetA;\n" // Bottom 32bits of uint64_t for lightSubs of worldcell we are in
    "uniform uint lightSubsetB;\n" //    Top 32bits of uint64_t for lightSubs of worldcell we are in
    "uniform uint activeLightCount;\n" // How many of the 64 bits are actually active lights, subsets must be tightly packed to one end!
//     "uniform vec3 worldMin;\n" // World bounds min (e.g., 0, 0, 0)
//     "uniform vec3 worldMax;\n" // World bounds max (e.g., 512*0.32, 512*0.32, 144*0.32)
//     "uniform ivec3 cellCounts;\n" // (64, 64, 18)

    "vec4 unpackColor32(uint color) {\n"
    "    return vec4(float((color >> 24) & 0xFF) / 255.0,\n"  // r
    "                float((color >> 16) & 0xFF) / 255.0,\n"  // g
    "                float((color >>  8) & 0xFF) / 255.0,\n"  // b
    "                float((color      ) & 0xFF) / 255.0);\n" // a
    "}\n"
    
    // --- Main Compute Shader ---
    "void main() {\n"
    "    uvec2 pixel = gl_GlobalInvocationID.xy;\n"
    "    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;\n"

    "    vec4 worldPosPack = imageLoad(inputWorldPos, ivec2(pixel));\n"
    "    vec3 worldPos = worldPosPack.xyz;\n"
    "    vec4 color = vec4(imageLoad(inputImage, ivec2(pixel)));\n"
    "    if (debugView == 1 || color.a < 1.0) return;\n"
    
    "    ivec3 cellIdx = ivec3(floor((worldPos - worldMin) / vec3(\n"
    "        (worldMax.x - worldMin.x) / cellCounts.x,\n"
    "        (worldMax.y - worldMin.y) / cellCounts.y,\n"
    "        (worldMax.z - worldMin.z) / cellCounts.z\n"
    "    )));\n"
//     "    int cell1D = cellIdx.x + cellIdx.y * cellCounts.x + cellIdx.z * cellCounts.x * cellCounts.y;\n"
    
    "    vec3 normal = normalize(imageLoad(inputNormals, ivec2(pixel)).xyz * 2.0 - 1.0);\n"
//     "    float depth = texture(inputDepth, ivec2(pixel)).r;\n"
    "    vec3 lighting = vec3(0.0,0.0,0.0);\n"

    "    ivec4 indicesPack = imageLoad(inputTexMaps, ivec2(pixel));\n"
    "    vec4 glowColor = unpackColor32(indicesPack.r);\n"
    "    vec4 specColor = unpackColor32(indicesPack.g);\n"
    "    int pixelInstance = floatBitsToInt(worldPosPack.a);\n"

    "    for (int i = 0; i < activeLightCount; i++) {\n"
    "        uint lightIdx = lightIndicesForSubset[i];\n"
    "        if (i < 32) {\n"
    "            if ((lightSubsetA & (1u << i)) == 0) continue;\n"
    "        } else {\n"
    "            if ((lightSubsetB & (1u << (i - 32))) == 0) continue;\n"
    "        }\n"
    
    "        float intensity = lights[lightIdx + 3];\n"
    "        if (intensity < 0.015) continue;\n"

    "        float range = lights[lightIdx + 4];\n"
    "        vec3 lightPos = vec3(lights[lightIdx + 0], lights[lightIdx + 1], lights[lightIdx + 2]);\n"
    "        vec3 toLight = lightPos - worldPos;\n"
    "        float dist = length(toLight);\n"
    "        if (dist > range) continue;\n"

    "        vec3 lightDir = normalize(toLight);\n"
    "        float spotAng = lights[lightIdx + 5];\n"
    "        vec3 spotDir = vec3(lights[lightIdx + 6], lights[lightIdx + 7], lights[lightIdx + 8]);\n"
    "        vec3 lightColor = vec3(lights[lightIdx + 9], lights[lightIdx + 10], lights[lightIdx + 11]);\n"
    "        float spotFalloff = 1.0;\n"
    "        if (spotAng > 0.0) {\n"
    "            float spotdot = dot(spotDir, -lightDir);\n"
    "            float cosAngle = cos(radians(spotAng / 2.0));\n"
    "            if (spotdot < cosAngle) continue;\n"
    "            float cosOuterAngle = cos(radians(spotAng / 2.0));\n"
    "            float cosInnerAngle = cos(radians(spotAng * 0.8 / 2.0));\n"
    "            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);\n"
    "            if (spotFalloff <= 0.0) continue;\n"
    "        }\n"

    "        float shadow = 1.0;\n"
    "        if (shadowsEnabled > 0 && intensity > 0.5 && range > 1.5) {\n"
    "            shadow = 1.0;\n"
    "        }\n"

    "        float attenuation = (1.0 - (dist / range)) * max(dot(normal, lightDir), 0.0);\n"
    "        attenuation *= shadow;\n"

    "        lighting += color.rgb * intensity * attenuation * lightColor * spotFalloff;\n"
    "    }\n"

    "    lighting += glowColor.rgb;\n"

    // Dither
    "    int pixelIndex = int(((int(pixel.y) % 64) * 64 + (int(pixel.x) % 64))) * 3;\n" // Calculate 1D index.  * 4 for four rgba values.
    "    vec4 bluenoise = vec4(blueNoiseColors[pixelIndex], blueNoiseColors[pixelIndex + 1], blueNoiseColors[pixelIndex + 2], 1.0);\n"
    "    lighting += ((bluenoise.rgb * 1.0/255.0) - (0.5/255.0));\n"

//     "    imageStore(outputImage, ivec2(pixel), vec4(lighting, color.a));\n"
    "    imageStore(inputImage, ivec2(pixel), vec4(lighting, color.a));\n"
    "}\n";
