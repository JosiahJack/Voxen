// deferred_lighting.compute
// Compute shader for processing 
const char* deferredLighting_computeShader =
    "#version 450 core\n"

    "layout(local_size_x = 32, local_size_y = 32) in;\n"

    "struct Instance {\n" // Ensure matches struct!
    "    int modelIndex;\n"
    "    int texIndex;\n"
    "    int glowIndex;\n"
    "    int specIndex;\n"
    "    int normIndex;\n"
    "    int lodIndex;\n"
    "    float posx;\n"
    "    float posy;\n"
    "    float posz;\n"
    "    float sclx;\n"
    "    float scly;\n"
    "    float sclz;\n"
    "    float rotx;\n"
    "    float roty;\n"
    "    float rotz;\n"
    "    float rotw;\n"
    "};\n"

    // G-buffer inputs
    "layout(rgba8,   binding = 0) uniform image2D inputImage;\n"
    "layout(rgba32f, binding = 1) uniform image2D inputWorldPos;\n"
    "layout(rgba32f, binding = 2) uniform image2D inputNormals;\n"
    "layout(std430, binding = 7) buffer BoundsBuffer { float bounds[]; };\n"
    "layout(std430, binding = 9) readonly buffer InstancesInPVS { uint instancesIndices[]; };\n"
    "layout(std430, binding = 10) readonly buffer InstancesBuffer { Instance instances[]; };\n"
    "layout(std430, binding = 11) readonly buffer InstancesMatricesBuffer { mat4 instanceMatrices[]; };\n"
    "layout(std430, binding = 12) buffer ColorBuffer { uint colors[]; };\n" // 1D color array (RGBA)
    "layout(std430, binding = 13) buffer BlueNoise { float blueNoiseColors[]; };\n"
    "layout(std430, binding = 14) buffer TextureOffsets { uint textureOffsets[]; };\n" // Starting index in colors for each texture
    "layout(std430, binding = 15) buffer TextureSizes { ivec2 textureSizes[]; };\n" // x,y pairs for width and height of textures
    "layout(std430, binding = 16) buffer TexturePalettes { uint texturePalettes[]; };\n" // Palette colors
    "layout(std430, binding = 17) buffer TexturePaletteOffsets { uint texturePaletteOffsets[]; };\n" // Palette starting indices for each texture
    "layout(std430, binding = 19) buffer LightIndices { float lightInPVS[]; };\n"
    "layout(rgba32f, binding = 4) uniform image2D outputImage;\n"

    // Uniforms, why must we all wear these ridiculous types!
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"
    "uniform int debugView;\n"
    
    "vec4 unpackColor32(uint color) {\n"
    "    return vec4(float((color >> 24) & 0xFF) / 255.0,\n"  // r
    "                float((color >> 16) & 0xFF) / 255.0,\n"  // g
    "                float((color >>  8) & 0xFF) / 255.0,\n"  // b
    "                float((color      ) & 0xFF) / 255.0);\n" // a
    "}\n"

     // --- Ray-Triangle Intersection (MÃ¶ller-Trumbore) ---
    "bool RayTriangle(vec3 origin, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out float t) {\n"
    "    vec3 edge1 = v1 - v0;\n"
    "    vec3 edge2 = v2 - v0;\n"
    "    vec3 h = cross(dir, edge2);\n"
    "    float a = dot(edge1, h);\n"
    "    if (abs(a) < 1e-6) return false;\n"

    "    float f = 1.0 / a;\n"
    "    vec3 s = origin - v0;\n"
    "    float u = f * dot(s, h);\n"
    "    if (u < 0.0 || u > 1.0) return false;\n"

    "    vec3 q = cross(s, edge1);\n"
    "    float v = f * dot(dir, q);\n"
    "    if (v < 0.0 || u + v > 1.0) return false;\n"

    "    t = f * dot(edge2, q);\n"
    "    return t > 0.001;\n"
    "}\n"
    
    "vec3 quat_rotate(vec4 q, vec3 v) {\n"
    "    float x2 = q.x + q.x;\n"
    "    float y2 = q.y + q.y;\n"
    "    float z2 = q.z + q.z;\n"

    "    float xx2 = q.x * x2;\n"
    "    float yy2 = q.y * y2;\n"
    "    float zz2 = q.z * z2;\n"

    "    float xy2 = q.x * y2;\n"
    "    float xz2 = q.x * z2;\n"
    "    float yz2 = q.y * z2;\n"

    "    float wx2 = q.w * x2;\n"
    "    float wy2 = q.w * y2;\n"
    "    float wz2 = q.w * z2;\n"

    "    return vec3(\n"
    "        v.x * (1.0 - yy2 - zz2) + v.y * (xy2 - wz2) + v.z * (xz2 + wy2),\n"
    "        v.x * (xy2 + wz2) + v.y * (1.0 - xx2 - zz2) + v.z * (yz2 - wx2),\n"
    "        v.x * (xz2 - wy2) + v.y * (yz2 + wx2) + v.z * (1.0 - xx2 - yy2)\n"
    "    );\n"
    "}\n"
    
    "const int MAX_VISIBLE_LIGHTS = 128;\n"
    "const int LIGHT_DATA_SIZE = 13;\n"
    "const int LIGHT_DATA_OFFSET_POSX = 0;\n"
    "const int LIGHT_DATA_OFFSET_POSY = 1;\n"
    "const int LIGHT_DATA_OFFSET_POSZ = 2;\n"
    "const int LIGHT_DATA_OFFSET_INTENSITY = 3;\n"
    "const int LIGHT_DATA_OFFSET_RANGE = 4;\n"
    "const int LIGHT_DATA_OFFSET_SPOTANG = 5;\n"
    "const int LIGHT_DATA_OFFSET_SPOTDIRX = 6;\n"
    "const int LIGHT_DATA_OFFSET_SPOTDIRY = 7;\n"
    "const int LIGHT_DATA_OFFSET_SPOTDIRZ = 8;\n"
    "const int LIGHT_DATA_OFFSET_SPOTDIRW = 9;\n"
    "const int LIGHT_DATA_OFFSET_R = 10;\n"
    "const int LIGHT_DATA_OFFSET_G = 11;\n"
    "const int LIGHT_DATA_OFFSET_B = 12;\n"
    
    // --- Main Compute Shader ---
    "void main() {\n"
    "    uvec2 pixel = gl_GlobalInvocationID.xy;\n"
    "    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;\n"

    "    vec4 worldPosPack = imageLoad(inputWorldPos, ivec2(pixel));\n"
    "    vec3 worldPos = worldPosPack.xyz;\n"
    "    vec4 color = vec4(imageLoad(inputImage, ivec2(pixel)));\n"
    "    if (debugView == 1 || color.a < 1.0) return;\n"

    "    vec4 normalPack = imageLoad(inputNormals, ivec2(pixel));\n"
    "    vec2 normalXY = unpackHalf2x16(floatBitsToInt(normalPack.r));\n"
    "    vec2 normalZ0 = unpackHalf2x16(floatBitsToInt(normalPack.g));\n"
    "    vec3 normal = normalize(vec3(normalXY.x,normalXY.y,normalZ0.x));\n"

    "    vec4 glowColor = unpackColor32(floatBitsToUint(normalPack.b));\n"
    "    vec4 specColor = unpackColor32(floatBitsToUint(normalPack.a));\n"
    "    vec3 lighting = vec3(0.0,0.0,0.0);\n"
    "    int pixelInstance = floatBitsToInt(worldPosPack.a);\n"
    "    uint lightIdx = 0;\n"
    "    for (int i = 0; i < MAX_VISIBLE_LIGHTS; i++) {\n"
    "        uint lightIdx = i * LIGHT_DATA_SIZE;\n" // LIGHT_DATA_SIZE
    "        float intensity = lightInPVS[lightIdx + LIGHT_DATA_OFFSET_INTENSITY];\n"

    "        float range = lightInPVS[lightIdx + LIGHT_DATA_OFFSET_RANGE];\n"
    "        vec3 lightPos = vec3(lightInPVS[lightIdx + LIGHT_DATA_OFFSET_POSX],\n"
    "                             lightInPVS[lightIdx + LIGHT_DATA_OFFSET_POSY],\n"
    "                             lightInPVS[lightIdx + LIGHT_DATA_OFFSET_POSZ]);\n"
    
    "        vec3 toLight = lightPos - worldPos;\n"
    "        float dist = length(toLight);\n"
    "        if (dist > range) continue;\n"

    "        vec3 lightDir = normalize(toLight);\n"
    "        float spotAng = lightInPVS[lightIdx + LIGHT_DATA_OFFSET_SPOTANG];\n"
    "        vec3 lightColor = vec3(lightInPVS[lightIdx + LIGHT_DATA_OFFSET_R],\n"
    "                               lightInPVS[lightIdx + LIGHT_DATA_OFFSET_G],\n"
    "                               lightInPVS[lightIdx + LIGHT_DATA_OFFSET_B]);\n"
    
    "        float spotFalloff = 1.0;\n"
    "        if (spotAng > 0.0) {\n"
    "            float quat_x = lightInPVS[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRX];\n"
    "            float quat_y = lightInPVS[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRY];\n"
    "            float quat_z = lightInPVS[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRZ];\n"
    "            float quat_w = lightInPVS[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRW];\n"
    "            vec4 quat = vec4(quat_x,quat_y,quat_z,quat_w);\n"
    "            vec3 baseDir = vec3(0.0,0.0,1.0);\n" // Forward vec
    "            vec3 spotDir = normalize(quat_rotate(quat,baseDir));\n"
    "            float spotdot = dot(spotDir, -lightDir);\n"
    "            float cosAngle = cos(radians(spotAng / 2.0));\n"
    "            if (spotdot < cosAngle) continue;\n"
    "            float cosOuterAngle = cos(radians(spotAng / 2.0));\n"
    "            float cosInnerAngle = cos(radians(spotAng * 0.8 / 2.0));\n"
    "            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);\n"
    "            if (spotFalloff <= 0.0) continue;\n"
    "        }\n"

    "        float distOverRange = dist / range;\n"
    "        float attenuation = (1.0 - (distOverRange * distOverRange)) * max(dot(normal, lightDir), 0.0);\n"
    "        lighting += color.rgb * (intensity * (1 / 2.2)) * attenuation * lightColor * spotFalloff;\n"
    "    }\n"

    "    lighting += glowColor.rgb;\n"

    // Dither
    "    int pixelIndex = int(((int(pixel.y) % 64) * 64 + (int(pixel.x) % 64))) * 3;\n" // Calculate 1D index.  * 4 for four rgba values.
    "    vec4 bluenoise = vec4(blueNoiseColors[pixelIndex], blueNoiseColors[pixelIndex + 1], blueNoiseColors[pixelIndex + 2], 1.0);\n"
    "    lighting += ((bluenoise.rgb * 1.0/255.0) - (0.5/255.0));\n"
    
    "    imageStore(outputImage, ivec2(pixel), vec4(lighting, color.a));\n"
    "}\n";
