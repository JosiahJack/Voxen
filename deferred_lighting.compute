// deferred_lighting.compute
// Compute shader for processing 
const char* deferredLighting_computeShader =
    "#version 450 core\n"
    "layout(local_size_x = 32, local_size_y = 32) in;\n"

    "layout(rgba8,   binding = 0) uniform image2D inputImage;\n"
    "layout(rgba32f, binding = 1) uniform image2D inputWorldPos;\n"
    "layout(rgba32f, binding = 2) uniform image2D inputNormals;\n"
//     "layout(std430, binding = 6) buffer LightmapData { float lightmapData[]; };\n"
    "layout(std430, binding = 8) buffer PrecomputedVisibleCellsFromHere { uint precomputedVisibleCellsFromHere[]; };\n"
    "layout(std430, binding = 13) buffer BlueNoise { float blueNoiseColors[]; };\n"
    "layout(std430, binding = 19) buffer LightIndices { float lights[]; };\n"
    "layout(std430, binding = 20) buffer CellIndexForInstance { uint cellIndexForInstance[]; };\n"
    "layout(std430, binding = 26) buffer VoxelLightListIndices { uint voxelLightListIndices[]; };\n"
    "layout(std430, binding = 27) buffer UniqueLightLists { uint uniqueLightLists[]; };\n"

    "uniform uint totalLuxelCount;\n"
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"
    "uniform uint modelCount;\n"
    "uniform mat4 viewProjection;\n"
    "uniform int debugView;\n"
    "uniform float worldMin_x;\n"
    "uniform float worldMin_z;\n"
    "uniform vec3 camPos;\n"
    "uniform float fogColorR;\n"
    "uniform float fogColorG;\n"
    "uniform float fogColorB;\n"

    "vec4 unpackColor32(uint color) {\n"
    "    return vec4(float((color >> 24) & 0xFF) / 255.0,\n"
    "                float((color >> 16) & 0xFF) / 255.0,\n"
    "                float((color >>  8) & 0xFF) / 255.0,\n"
    "                float((color      ) & 0xFF) / 255.0);\n"
    "}\n"

    "vec3 quat_rotate(vec4 q, vec3 v) {\n"
    "    float x2 = q.x + q.x;\n"
    "    float y2 = q.y + q.y;\n"
    "    float z2 = q.z + q.z;\n"
    "    float xx2 = q.x * x2;\n"
    "    float yy2 = q.y * y2;\n"
    "    float zz2 = q.z * z2;\n"
    "    float xy2 = q.x * y2;\n"
    "    float xz2 = q.x * z2;\n"
    "    float yz2 = q.y * z2;\n"
    "    float wx2 = q.w * x2;\n"
    "    float wy2 = q.w * y2;\n"
    "    float wz2 = q.w * z2;\n"
    "    return vec3(\n"
    "        v.x * (1.0 - yy2 - zz2) + v.y * (xy2 - wz2) + v.z * (xz2 + wy2),\n"
    "        v.x * (xy2 + wz2) + v.y * (1.0 - xx2 - zz2) + v.z * (yz2 - wx2),\n"
    "        v.x * (xz2 - wy2) + v.y * (yz2 + wx2) + v.z * (1.0 - xx2 - yy2)\n"
    "    );\n"
    "}\n"

    "const int LIGHT_DATA_SIZE = 13;\n"
    "const int LIGHT_DATA_OFFSET_POSX = 0;\n"
    "const int LIGHT_DATA_OFFSET_POSY = 1;\n"
    "const int LIGHT_DATA_OFFSET_POSZ = 2;\n"
    "const int LIGHT_DATA_OFFSET_INTENSITY = 3;\n"
    "const int LIGHT_DATA_OFFSET_RANGE = 4;\n"
    "const int LIGHT_DATA_OFFSET_SPOTANG = 5;\n"
    "const int LIGHT_DATA_OFFSET_SPOTDIRX = 6;\n"
    "const int LIGHT_DATA_OFFSET_SPOTDIRY = 7;\n"
    "const int LIGHT_DATA_OFFSET_SPOTDIRZ = 8;\n"
    "const int LIGHT_DATA_OFFSET_SPOTDIRW = 9;\n"
    "const int LIGHT_DATA_OFFSET_R = 10;\n"
    "const int LIGHT_DATA_OFFSET_G = 11;\n"
    "const int LIGHT_DATA_OFFSET_B = 12;\n"
    "const float WORLDCELL_WIDTH_F = 2.56;\n"
    "const float VOXEL_SIZE = 0.32;\n"
    "const float CELLXHALF = 1.28;\n"
    "const vec3 baseDir = vec3(0.0, 0.0, 1.0);\n"

    "uint GetVoxelIndex(vec3 worldPos) {\n"
    "    float offsetX = worldPos.x - worldMin_x + (VOXEL_SIZE * 0.5);\n"
    "    float offsetZ = worldPos.z - worldMin_z + (VOXEL_SIZE * 0.5);\n"
    "    uint cellX = uint(offsetX / WORLDCELL_WIDTH_F);\n"
    "    uint cellZ = uint(offsetZ / WORLDCELL_WIDTH_F);\n"
    "    float localX = mod(offsetX, WORLDCELL_WIDTH_F);\n"
    "    float localZ = mod(offsetZ, WORLDCELL_WIDTH_F);\n"
    "    uint voxelX = uint(localX / VOXEL_SIZE);\n"
    "    uint voxelZ = uint(localZ / VOXEL_SIZE);\n"
    "    uint cellIndex = cellZ * 64 + cellX;\n"
    "    uint voxelIndexInCell = voxelZ * 8 + voxelX;\n"
    "    return cellIndex * 64 + voxelIndexInCell;\n"
    "}\n"

    "uvec2 PosToCellCoords(float pos_x, float pos_z) {\n"
    "    uvec2 retval;\n"
    "    retval.x = uint(int((pos_x - worldMin_x + CELLXHALF) / WORLDCELL_WIDTH_F));\n"
    "    retval.y = uint(int((pos_z - worldMin_z + CELLXHALF) / WORLDCELL_WIDTH_F));\n"
    "    return retval;\n"
    "}\n"

    // Main Compute Shader
    "void main() {\n"
    "    uvec2 pixel = gl_GlobalInvocationID.xy;\n"
    "    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;\n"

    "    vec4 worldPosPack = imageLoad(inputWorldPos, ivec2(pixel));\n"
    "    vec3 worldPos = worldPosPack.xyz;\n"
    "    vec4 color = vec4(imageLoad(inputImage, ivec2(pixel)));\n"
    "    float distToPixel = length(worldPos - camPos);\n"
    "    vec4 normalPack = imageLoad(inputNormals, ivec2(pixel));\n"
    "    vec4 glowColor = unpackColor32(floatBitsToUint(normalPack.b));\n"
    "    vec2 uv_lm = unpackHalf2x16(floatBitsToInt(normalPack.a));\n" // Assume lightmap UVs in normalPack.a
    "    int pixelInstance = floatBitsToInt(worldPosPack.a);\n"

    // Debug View: Output lightmap color
//     "if (debugView == 8) {\n"
//         "uint tilesX = 12;\n"
//         " uint tileXpix = pixel.x / 64u;\n"
//         " uint tileYpix = pixel.y / 64u;\n"
//         " uint tileIndex = tileYpix * tilesX + tileXpix;\n"
//         " uint maxTiles = totalLuxelCount / 4096u;\n"
//         " if (tileIndex < maxTiles) {\n"
//         " uint localX = pixel.x % 64u;\n"
//         " uint localY = pixel.y % 64u;\n"
//         " uint luxelIndex = tileIndex * 4096u + localY * 64u + localX;\n"
//         " uint li = luxelIndex * 4u;\n"
//         " vec3 lm = vec3(lightmapData[li + 0u], lightmapData[li + 1u], lightmapData[li + 2u]);\n"
//         " imageStore(inputImage, ivec2(pixel), vec4(lm, 1.0));\n"
//         " } else {\n"
//         " imageStore(inputImage, ivec2(pixel), vec4(0.0, 0.0, 0.0, 1.0));\n"
//         " }\n"
//         " return;\n"
//     "}\n"

    // Regular lighting calculation
    "    uint voxelIdx = GetVoxelIndex(worldPos);\n"
    "    uint count  = voxelLightListIndices[voxelIdx * 2 + 1];\n"
    "    vec2 shadowUV = vec2(float(pixel.x)/screenWidth, float(pixel.y)/screenHeight);\n"
//     "    float occlusion = texture(shadowOcclusionTex, shadowUV).r;\n" // Bilinear sample
    "    float occlusion = 0.0;\n"
    
    "    vec3 lighting = vec3(0.0, 0.0, 0.0);\n"
    "    vec3 normal = vec3(0.0,0.0,0.0);\n"
    "    uint listoffset = 0;\n"
    "    if (count > 0) {\n"
    "        vec2 normalXY = unpackHalf2x16(floatBitsToInt(normalPack.r));\n"
    "        vec2 normalZ0 = unpackHalf2x16(floatBitsToInt(normalPack.g));\n"
    "        normal = vec3(normalXY.x, normalXY.y, normalZ0.x);\n"        
    "        listoffset = voxelLightListIndices[voxelIdx * 2];\n"
    "    }\n"
    
    "    for (uint i = 0; i < count; i++) {\n"
    "        uint lightIdxInPVS = uniqueLightLists[listoffset + i];\n"
    "        uint lightIdx = lightIdxInPVS * LIGHT_DATA_SIZE;\n"
    "        float intensity = lights[lightIdx + LIGHT_DATA_OFFSET_INTENSITY];\n"
    "        if (intensity < 0.05) continue;\n"

    "        float range = lights[lightIdx + LIGHT_DATA_OFFSET_RANGE];\n"
    "        vec3 lightPos = vec3(lights[lightIdx + LIGHT_DATA_OFFSET_POSX],\n"
    "                             lights[lightIdx + LIGHT_DATA_OFFSET_POSY],\n"
    "                             lights[lightIdx + LIGHT_DATA_OFFSET_POSZ]);\n"
    "        vec3 toLight = lightPos - worldPos;\n"
    "        float dist = length(toLight);\n"
    "        if (dist > range) continue;\n"

    "        vec3 lightDir = normalize(toLight);\n"
    "        float lambertian = max(dot(normal, lightDir), 0.0);\n"
    "        if (lambertian < 0.25) continue;\n"

    "        if (dist > 2.56) {\n"
    "            uvec2 lightCell = PosToCellCoords(lightPos.x, lightPos.z);\n"
    "            uint checkCellIdx = cellIndexForInstance[pixelInstance];\n"
    "            uint lightCellIdx1D = (lightCell.y * 64) + lightCell.x;\n"
    "            uint bitIndex = lightCellIdx1D * 4096 + checkCellIdx;\n"
    "            uint wordIdx = bitIndex / 32;\n"
    "            uint bitPos = bitIndex % 32;\n"
    "            bool lightCanSeeCell = (precomputedVisibleCellsFromHere[wordIdx] & (1u << bitPos)) != 0u;\n"
    "            if (!lightCanSeeCell) continue;\n"
    "        }\n"

    "        float spotAng = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTANG];\n"
    "        float spotFalloff = 1.0;\n"
    "        if (spotAng > 0.0) {\n"
    "            float quat_x = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRX];\n"
    "            float quat_y = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRY];\n"
    "            float quat_z = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRZ];\n"
    "            float quat_w = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRW];\n"
    "            vec4 quat = vec4(quat_x, quat_y, quat_z, quat_w);\n"
    "            vec3 spotDir = normalize(quat_rotate(quat, baseDir));\n"
    "            float spotdot = dot(spotDir, -lightDir);\n"
    "            float cosAngle = cos(radians(spotAng / 2.0));\n"
    "            if (spotdot < cosAngle) continue;\n"
    "            float cosOuterAngle = cos(radians(spotAng / 2.0));\n"
    "            float cosInnerAngle = cos(radians(spotAng * 0.8 / 2.0));\n"
    "            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);\n"
    "            if (spotFalloff <= 0.0) continue;\n"
    "        }\n"

    "        vec3 lightColor = vec3(lights[lightIdx + LIGHT_DATA_OFFSET_R],\n"
    "                               lights[lightIdx + LIGHT_DATA_OFFSET_G],\n"
    "                               lights[lightIdx + LIGHT_DATA_OFFSET_B]);\n"
    "        float distOverRange = dist / range;\n"
    "        float attenuation = (1.0 - (distOverRange * distOverRange)) * lambertian;\n"
    "        float shadow = 1.0 - occlusion;\n"
    "        lighting += color.rgb * (intensity * 0.4) * pow(attenuation, 1.6) * lightColor * spotFalloff * shadow;\n"
    "    }\n"

    "    lighting += glowColor.rgb;\n"

    // Dither
    "    int blueNoiseTextureWidth = 64;\n"
    "    int pixelIndex = int(((int(pixel.y) % blueNoiseTextureWidth) * blueNoiseTextureWidth + (int(pixel.x) % blueNoiseTextureWidth))) * 3;\n"
    "    vec4 bluenoise = vec4(blueNoiseColors[pixelIndex], blueNoiseColors[pixelIndex + 1], blueNoiseColors[pixelIndex + 2], 1.0);\n"
    "    lighting += ((bluenoise.rgb * 1.0/255.0) - (0.5/255.0));\n"

    // Fog
    "    float fogFac = clamp(distToPixel / 71.68, 0.0, 1.0);\n"
    "    float lum = dot(lighting, vec3(0.299, 0.587, 0.114));\n"
    "    vec3 fogColor = vec3(fogColorR, fogColorG, fogColorB);\n"
    "    fogFac = clamp(fogFac * (1.0 - lum), 0.0, 1.0);\n"
    "    lighting = mix(fogColor, lighting, 1.0 - fogFac);\n"
    "    imageStore(inputImage, ivec2(pixel), vec4(lighting, color.a));\n"
    "}\n";
