// deferred_lighting.compute
// Compute shader for processing 
const char *deferredLighting_computeShader =
    "#version 450 core\n"

    "layout(local_size_x = 8, local_size_y = 8) in;\n"

    // G-buffer inputs
    "layout(rgba8,   binding = 0) uniform image2D inputImage;\n"
    "layout(rgba16f, binding = 1) uniform image2D inputNormals;\n"
    "layout(binding = 2) uniform sampler2D inputDepth;\n"
    "layout(rgba32f, binding = 3) uniform image2D inputWorldPos;\n"
    "layout(rgba32f, binding = 4) uniform image2D outputImage;\n"
    "layout(rgba32i, binding = 5) uniform iimage2D inputModelInstanceID;\n"

    // Light buffer
    "layout(std430, binding = 5) buffer LightBuffer {\n"
    "    float lights[];\n"
    "};\n"

    // Vertex buffers (one per model, bound as SSBOs)
    "#define MODEL_COUNT 6\n"
    "layout(std430, binding = 6) buffer VertexBuffer0 { float vertices0[]; };\n"
    "layout(std430, binding = 7) buffer VertexBuffer1 { float vertices1[]; };\n"
    "layout(std430, binding = 8) buffer VertexBuffer2 { float vertices2[]; };\n"
    "layout(std430, binding = 9) buffer BoundsBuffer { float bounds[]; };\n"

    "struct Instance {\n"
    "    int modelIndex;\n"
    "    float posx;\n"
    "    float posy;\n"
    "    float posz;\n"
    "    float sclx;\n"
    "    float scly;\n"
    "    float sclz;\n"
    "    float rotx;\n"
    "    float roty;\n"
    "    float rotz;\n"
    "    float rotw;\n"
    "};\n"

    "layout(std430, binding = 10) buffer InstancesBuffer {\n"
    "    Instance instances[];\n"
    "};\n"

    "layout(std430, binding = 11) buffer InstanceBuffer {\n"
    "    mat4 instanceMatrices[];\n"
    "};\n"

    "layout(std430, binding = 12) buffer ColorBuffer {\n"
    "    float colors[];\n" // 1D color array (RGBA)
    "};\n"

    "uniform uint textureOffsets[];\n" // Offsets for each texture
    "uniform ivec2 textureSizes[];\n" // Width, height for each texture

    // Uniforms from deferred shader
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"

    // Uniforms for ray tracing
    "uniform int shadowsEnabled;\n"
    "uniform int triangleCounts[MODEL_COUNT];\n" // Triangles per model
    "uniform int instanceCount;\n"

    // --- Ray-AABB Intersection --- Ray-OBB actually, ray translated in TraceRay that calls this
    "bool RayAABB(vec3 origin, vec3 dir, float minx, float miny, float minz, float maxx, float maxy, float maxz, float maxDist) {\n"
    "    vec3 invDir = 1.0 / dir;\n"
    "    vec3 tMin = (vec3(minx, miny, minz) - origin) * invDir;\n"
    "    vec3 tMax = (vec3(maxx, maxy, maxz) - origin) * invDir;\n"
    "    vec3 t1 = min(tMin, tMax);\n"
    "    vec3 t2 = max(tMin, tMax);\n"
    "    float tNear = max(max(t1.x, t1.y), t1.z);\n"
    "    float tFar = min(min(t2.x, t2.y), t2.z);\n"
    "    return tNear <= tFar && tNear < maxDist && tFar > 0.0;\n"
    "}\n"

    // --- Ray-Triangle Intersection (MÃ¶ller-Trumbore) ---
    "bool RayTriangle(vec3 origin, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out float t) {\n"
    "    vec3 edge1 = v1 - v0;\n"
    "    vec3 edge2 = v2 - v0;\n"
    "    vec3 h = cross(dir, edge2);\n"
    "    float a = dot(edge1, h);\n"
    "    if (abs(a) < 1e-8) return false;\n"

    "    float f = 1.0 / a;\n"
    "    vec3 s = origin - v0;\n"
    "    float u = f * dot(s, h);\n"
    "    if (u < 0.0 || u > 1.0) return false;\n"

    "    vec3 q = cross(s, edge1);\n"
    "    float v = f * dot(dir, q);\n"
    "    if (v < 0.0 || u + v > 1.0) return false;\n"

    "    t = f * dot(edge2, q);\n"
    "    return t > 0.001;\n"
    "}\n"

    // --- Trace Ray for Shadow ---
    "float TraceRay(vec3 origin, vec3 dir, float maxDist) {\n"
    "    for (int i = 0; i < instanceCount; i++) {\n"
    "        if (i == 3) continue;\n" // Test light

    "        Instance inst = instances[i];\n"
    "        mat4 invModel = inverse(instanceMatrices[i]);\n"
    "        vec3 localOrigin = (invModel * vec4(origin, 1.0)).xyz;\n"
    "        vec3 localDir = ((invModel * vec4(dir, 0.0)).xyz);\n"
    "        int boundsBase = int(inst.modelIndex) * 6;\n"
    "        float minx = bounds[boundsBase + 0];\n"
    "        float miny = bounds[boundsBase + 1];\n"
    "        float minz = bounds[boundsBase + 2];\n"
    "        float maxx = bounds[boundsBase + 3];\n"
    "        float maxy = bounds[boundsBase + 4];\n"
    "        float maxz = bounds[boundsBase + 5];\n"
    "        float blockFac = 0.0;\n"
    "        float jitter = 0.01;\n"
    "        if (RayAABB(localOrigin, localDir, minx, miny, minz, maxx, maxy, maxz, maxDist)) blockFac += 1.0;\n"
//     "        if (RayAABB(localOrigin + vec3(jitter,0.0,0.0), localDir, minx, miny, minz, maxx, maxy, maxz, maxDist)) blockFac += 1.0;\n"
//     "        if (RayAABB(localOrigin + vec3(0.0,jitter,0.0), localDir, minx, miny, minz, maxx, maxy, maxz, maxDist)) blockFac += 1.0;\n"
//     "        if (RayAABB(localOrigin + vec3(0.0,0.0,jitter), localDir, minx, miny, minz, maxx, maxy, maxz, maxDist)) blockFac += 1.0;\n"
//     "        if (RayAABB(localOrigin + vec3(-jitter,0.0,0.0), localDir, minx, miny, minz, maxx, maxy, maxz, maxDist)) blockFac += 1.0;\n"
//     "        if (RayAABB(localOrigin + vec3(0.0,-jitter,0.0), localDir, minx, miny, minz, maxx, maxy, maxz, maxDist)) blockFac += 1.0;\n"
//     "        if (RayAABB(localOrigin + vec3(0.0,0.0,-jitter), localDir, minx, miny, minz, maxx, maxy, maxz, maxDist)) blockFac += 1.0;\n"
//     "        return 1.0 - (blockFac / 7.0);\n"
    "           return 1.0 - blockFac;\n"
//     "            int triCount = triangleCounts[inst.modelIndex];\n"
//     "            for (int tri = 0; tri < triCount; tri++) {\n"
//     "                int base = tri * 24;\n"
//     "                vec3 v0, v1, v2;\n"
//     "                if (inst.modelIndex == 0) {\n"
//     "                    v0 = vec3(vertices0[base + 0], vertices0[base + 1], vertices0[base + 2]);\n"
//     "                    v1 = vec3(vertices0[base + 8], vertices0[base + 9], vertices0[base + 10]);\n"
//     "                    v2 = vec3(vertices0[base + 16], vertices0[base + 17], vertices0[base + 18]);\n"
//     "                } else if (inst.modelIndex == 1) {\n"
//     "                    v0 = vec3(vertices1[base + 0], vertices1[base + 1], vertices1[base + 2]);\n"
//     "                    v1 = vec3(vertices1[base + 8], vertices1[base + 9], vertices1[base + 10]);\n"
//     "                    v2 = vec3(vertices1[base + 16], vertices1[base + 17], vertices1[base + 18]);\n"
//     "                } else if (inst.modelIndex == 2) {\n"
//     "                    v0 = vec3(vertices2[base + 0], vertices2[base + 1], vertices2[base + 2]);\n"
//     "                    v1 = vec3(vertices2[base + 8], vertices2[base + 9], vertices2[base + 10]);\n"
//     "                    v2 = vec3(vertices2[base + 16], vertices2[base + 17], vertices2[base + 18]);\n"
//     "                }\n"
//     "                float t;\n"
//     "                if (RayTriangle(localOrigin, localDir, v0, v1, v2, t) && t < maxDist) return 1.0;\n"
//     "            }\n"
//     "        }\n"
    "    }\n"
    "    return 1.0;\n"
    "}\n"

    // --- Main Compute Shader ---
    "void main() {\n"
    "    uvec2 pixel = gl_GlobalInvocationID.xy;\n"
    "    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;\n"

    "    vec3 worldPos = imageLoad(inputWorldPos, ivec2(pixel)).xyz;\n"
    "    vec4 color = imageLoad(inputImage, ivec2(pixel));\n"
    "    vec3 normal = normalize(imageLoad(inputNormals, ivec2(pixel)).xyz * 2.0 - 1.0);\n"
    "    float depth = texture(inputDepth, ivec2(pixel)).r;\n"
    "    vec3 lighting = vec3(0.0,0.0,0.0);\n"

    "    int texIndex = imageLoad(inputModelInstanceID, ivec2(pixel)).b;\n"
    "    if (texIndex == 3) {\n"
    "        lighting = color.rgb;\n"
    "    } else {\n"
        "    for (int i = 0; i < lights.length(); i += 12) {\n" // Stride of 12
        "        float intensity = lights[i + 3];\n"
        "        if (intensity < 0.015) continue;\n"

        "        float range = lights[i + 4];\n"
        "        vec3 lightPos = vec3(lights[i + 0], lights[i + 1], lights[i + 2]);\n"
        "        vec3 toLight = lightPos - worldPos;\n"
        "        float dist = length(toLight);\n"
        "        if (dist > range) continue;\n"

        "        vec3 lightDir = normalize(toLight);\n"
        "        float spotAng = lights[i + 5];\n"
        "        vec3 spotDir = vec3(lights[i + 6], lights[i + 7], lights[i + 8]);\n"
        "        vec3 lightColor = vec3(lights[i + 9], lights[i + 10], lights[i + 11]);\n"
        "        float spotFalloff = 1.0;\n"
        "        if (spotAng > 0.0) {\n"
        "            float spotdot = dot(spotDir, -lightDir);\n"
        "            float cosAngle = cos(radians(spotAng / 2.0));\n"
        "            if (spotdot < cosAngle) continue;\n"
        "            float cosOuterAngle = cos(radians(spotAng / 2.0));\n"
        "            float cosInnerAngle = cos(radians(spotAng * 0.8 / 2.0));\n"
        "            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);\n"
        "            if (spotFalloff <= 0.0) continue;\n"
        "        }\n"

        "        float shadow = 1.0;\n"
        "        if (shadowsEnabled > 0 && intensity > 0.5 && range > 1.5) {\n"
        "            shadow = TraceRay(worldPos + normal * 0.01, lightDir, 100.0);\n"
        "        }\n"

        "        float attenuation = (1.0 - (dist / range)) * max(dot(normal, lightDir), 0.0);\n"
        "        attenuation *= shadow;\n"

        "        lighting += color.rgb * intensity * attenuation * lightColor * spotFalloff;\n"
        "    }\n"
    "    }\n"

    // Dither
    "    int blueNoiseTextureIndex = 4;\n"
    "    ivec2 texSize = textureSizes[blueNoiseTextureIndex];\n"
    "    int pixelIndex = int(textureOffsets[blueNoiseTextureIndex] * 4) + ((int(pixel.y) % texSize.y) * texSize.x + (int(pixel.x) % texSize.x)) * 4;\n" // Calculate 1D index.  * 4 for four rgba values.
    "    vec4 bluenoise = vec4(colors[pixelIndex], colors[pixelIndex + 1], colors[pixelIndex + 2], colors[pixelIndex + 3]);\n"
    "    lighting += ((bluenoise.rgb * 1.0/255.0) - (0.5/255.0));\n"

    "    imageStore(outputImage, ivec2(pixel), vec4(lighting, color.a));\n"
    "}\n";
