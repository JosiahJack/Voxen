const char *transform_computeShader =
    "#version 450 core\n"
    "layout(local_size_x = 64) in;\n" // 64 threads per workgroup, adjustable
    "\n"
    "layout(std430, binding = 0) buffer VertexBufferIn {\n"
    "    float verticesIn[];\n"
    "};\n"
    "\n"
    "layout(std430, binding = 1) buffer VertexBufferOut {\n"
    "    float verticesOut[];\n"
    "};\n"
    "\n"
    "struct InstanceData {\n"
    "    vec3 position;\n"
    "    vec4 rotation;\n" // Quaternion for instance rotation\n"
    "    vec3 scale;\n"    // Scale (set to 1.0 for now)\n"
    "    uint modelIndex;\n"
    "};\n"
    "\n"
    "layout(std430, binding = 2) buffer InstanceBuffer {\n"
    "    InstanceData instances[];\n"
    "};\n"
    "\n"
    "uniform uint vertexCount;\n"
    "uniform uint instanceCount;\n"
    "uniform uint modelVertexCounts[3]; // Match MODEL_COUNT\n"
    "uniform uint vbo_offsets[3];       // Match MODEL_COUNT\n"
    "uniform vec3 cameraPos;\n"         // Camera position\n"
    "uniform float cameraYaw;           // Camera yaw in degrees\n"
    "uniform float cameraPitch;         // Camera pitch in degrees\n"
    "uniform float fov;                 // Vertical FOV in degrees\n"
    "uniform float aspect;              // Aspect ratio (width/height)\n"
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"
    "\n"
    "void main() {\n"
    "    uint globalIdx = gl_GlobalInvocationID.x;\n"
    "    if (globalIdx >= vertexCount) return;\n"
    "\n"
    "    // Determine which model and instance this vertex belongs to\n"
    "    uint cumulativeCount = 0;\n"
    "    uint modelIdx = 0;\n"
    "    for (uint i = 0; i < 3; i++) {\n"
    "        if (globalIdx < cumulativeCount + modelVertexCounts[i]) {\n"
    "            modelIdx = i;\n"
    "            break;\n"
    "        }\n"
    "        cumulativeCount += modelVertexCounts[i];\n"
    "    }\n"
    "    uint localVertexIdx = globalIdx - vbo_offsets[modelIdx];\n"
    "    uint instanceID = localVertexIdx / (modelVertexCounts[modelIdx] / instanceCount);\n"
    "    if (instanceID >= instanceCount) instanceID = 0; // Fallback\n"
    "\n"
    "    // Load input vertex data (9 floats: x,y,z,nx,ny,nz,u,v,texIndex)\n"
    "    uint inIdx = globalIdx * 9;\n"
    "    vec3 position = vec3(verticesIn[inIdx + 0], verticesIn[inIdx + 1], verticesIn[inIdx + 2]);\n"
    "    vec2 uv = vec2(verticesIn[inIdx + 6], verticesIn[inIdx + 7]);\n"
    "    float texIndex = verticesIn[inIdx + 8];\n"
    "\n"
    "    // Instance transformation (model to world space)\n"
    "    vec3 instancePos = instances[instanceID].position;\n"
    "    position += instancePos; // Simple translation for now (no rotation/scale)\n"
    "\n"
    "    // Compute vector from camera to vertex\n"
    "    vec3 toVertex = position - cameraPos;\n"
    "    float distance = length(toVertex);\n"
    "    if (distance < 0.001) distance = 0.001; // Avoid division by zero\n"
    "\n"
    "    // Compute yaw and pitch relative to camera\n"
    "    float yaw = degrees(atan(toVertex.x, toVertex.z)); // Yaw in degrees, x/z plane\n"
    "    float pitch = degrees(asin(toVertex.y / distance)); // Pitch in degrees\n"
    "\n"
    "    // Adjust for camera orientation\n"
    "    yaw += cameraYaw;\n"
    "    pitch += cameraPitch;\n"
    "\n"
    "    // Map to screen coordinates\n"
    "    float halfFov = fov / 2.0;\n"
    "    float yawRange = halfFov * aspect; // Horizontal FOV\n"
    "    float minYaw = cameraYaw - yawRange;\n"
    "    float maxYaw = cameraYaw + yawRange;\n"
    "    float minPitch = cameraPitch - halfFov;\n"
    "    float maxPitch = cameraPitch + halfFov;\n"
    "\n"
    "    float screenX = (yaw - minYaw) / (maxYaw - minYaw) * float(screenWidth);\n"
    "    float screenY = (pitch - minPitch) / (maxPitch - minPitch) * float(screenHeight);\n"
    "\n"
    "    // Clamp to screen bounds\n"
    "    screenX = clamp(screenX, 0.0, float(screenWidth - 1));\n"
    "    screenY = clamp(screenY, 0.0, float(screenHeight - 1));\n"
    "\n"
    "    // Write transformed vertex data to output buffer (yaw, pitch, distance, u, v, texIndex)\n"
    "    uint outIdx = globalIdx * 6;\n"
    "    verticesOut[outIdx + 0] = screenX;      // yaw -> x pixel coordinate\n"
    "    verticesOut[outIdx + 1] = screenY;      // pitch -> y pixel coordinate\n"
    "    verticesOut[outIdx + 2] = distance;     // distance -> depth\n"
    "    verticesOut[outIdx + 3] = uv.x;\n"
    "    verticesOut[outIdx + 4] = uv.y;\n"
    "    verticesOut[outIdx + 5] = texIndex;\n"
    "}\n";
