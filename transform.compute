const char *transform_computeShader =
    "#version 450 core\n"
    "layout(local_size_x = 64) in;\n" // 64 threads per workgroup, adjustable to max vertices per model
    "\n"
    "layout(std430, binding = 0) buffer VertexBufferIn {\n"
    "    float verticesIn[];\n"
    "};\n"
    "\n"
    "layout(std430, binding = 1) buffer VertexBufferOut {\n"
    "    float verticesOut[];\n"
    "};\n"
    "\n"
    "struct InstanceData {\n"
    "    vec3 position;\n"
    "    vec4 rotation;\n" // Quaternion for instance rotation\n"
    "    vec3 scale;\n"    // Scale\n"
    "    uint modelIndex;\n"
    "};\n"
    "\n"
    "layout(std430, binding = 2) buffer InstanceBuffer {\n"
    "    InstanceData instances[];\n"
    "};\n"
    "\n"
    "uniform uint vertexCount;\n"         // Total vertices across all models\n"
    "uniform uint instanceCount;\n"       // Total number of instances\n"
    "uniform uint modelVertexCounts[3];  // Vertices per model\n"
    "uniform uint vbo_offsets[3];        // Starting offsets for each model\n"
    "uniform vec3 cameraPos;\n"          // Camera position\n"
    "uniform float cameraYaw;\n"         // Camera yaw in degrees\n"
    "uniform float cameraPitch;\n"       // Camera pitch in degrees\n"
    "uniform float fovV;\n"              // Vertical FOV in degrees\n"
    "uniform float fovH;\n"              // Horizontal FOV in degrees\n"
    "uniform float aspect;\n"            // Aspect ratio (width/height)\n"
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"
    "\n"
    "// Quaternion to 3x3 rotation matrix\n"
    "mat3 quat_to_mat3(vec4 q) {\n"
    "    float x2 = q.x * q.x;\n"
    "    float y2 = q.y * q.y;\n"
    "    float z2 = q.z * q.z;\n"
    "    float xy = q.x * q.y;\n"
    "    float xz = q.x * q.z;\n"
    "    float yz = q.y * q.z;\n"
    "    float wx = q.w * q.x;\n"
    "    float wy = q.w * q.y;\n"
    "    float wz = q.w * q.z;\n"
    "\n"
    "    return mat3(\n"
    "        1.0 - 2.0 * (y2 + z2), 2.0 * (xy + wz), 2.0 * (xz - wy),\n"
    "        2.0 * (xy - wz), 1.0 - 2.0 * (x2 + z2), 2.0 * (yz + wx),\n"
    "        2.0 * (xz + wy), 2.0 * (yz - wx), 1.0 - 2.0 * (x2 + y2)\n"
    "    );\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    uint instanceID = gl_GlobalInvocationID.x;\n" // One instance per workgroup thread\n"
    "    if (instanceID >= instanceCount) return;\n"
    "\n"
    "    // Get instance data\n"
    "    InstanceData instance = instances[instanceID];\n"
    "    uint modelIdx = instance.modelIndex;\n"
    "    uint vertCount = modelVertexCounts[modelIdx];\n"
    "    uint baseOffset = vbo_offsets[modelIdx];\n"
    "\n"
    "    // Local vertex index within the workgroup (0 to vertCount-1)\n"
    "    uint localIdx = gl_LocalInvocationID.x;\n"
    "    if (localIdx >= vertCount) return;\n"
    "\n"
    "    // Global output index for this instance's vertices\n"
    "    uint globalOutIdx = (instanceID * vertexCount) + localIdx;\n"
    "\n"
    "    // Load input vertex data\n"
    "    uint inIdx = (baseOffset + localIdx) * 9;\n"
    "    vec3 position = vec3(verticesIn[inIdx + 0], verticesIn[inIdx + 1], verticesIn[inIdx + 2]);\n"
    "    vec2 uv = vec2(verticesIn[inIdx + 6], verticesIn[inIdx + 7]);\n"
    "    float texIndex = verticesIn[inIdx + 8];\n"
    "\n"
    "    // Instance transformation (model to world space)\n"
    "    vec3 scaledPos = position * instance.scale;\n"
    "    mat3 rotMat = quat_to_mat3(instance.rotation);\n"
    "    vec3 worldPos = rotMat * scaledPos + instance.position;\n"
    "\n"
    "    // Compute vector from camera to vertex\n"
    "    vec3 toVertex = worldPos - cameraPos;\n"
    "    float distance = length(toVertex);\n"
    "    if (distance < 0.001) distance = 0.001; // Avoid division by zero\n"
    "\n"
    "    // Compute yaw and pitch relative to camera\n"
    "    float yaw = degrees(atan(toVertex.x, toVertex.z)); // Yaw in degrees, x/z plane\n"
    "    float pitch = degrees(asin(toVertex.y / distance)); // Pitch in degrees\n"
    "\n"
    "    // Adjust for camera orientation\n"
    "    yaw += cameraYaw;\n"
    "    pitch += cameraPitch;\n"
    "\n"
    "    // Map to screen coordinates\n"
    "    float halfFov = fovV / 2.0;\n"
    "    float yawRange = fovH / 2.0;\n"
    "    float minYaw = cameraYaw - yawRange;\n"
    "    float maxYaw = cameraYaw + yawRange;\n"
    "    float minPitch = cameraPitch - halfFov;\n"
    "    float maxPitch = cameraPitch + halfFov;\n"
    "\n"
    "    float screenX = (yaw - minYaw) / (maxYaw - minYaw) * float(screenWidth);\n"
    "    float screenY = (pitch - minPitch) / (maxPitch - minPitch) * float(screenHeight);\n"
    "\n"
    "    // Clamp to screen bounds\n"
    "    screenX = clamp(screenX, 0.0, float(screenWidth - 1));\n"
    "    screenY = clamp(screenY, 0.0, float(screenHeight - 1));\n"
    "\n"
    "    // Write transformed vertex data to output buffer\n"
    "    uint outIdx = globalOutIdx * 6;\n"
    "    verticesOut[outIdx + 0] = screenX;      // yaw -> x pixel coordinate\n"
    "    verticesOut[outIdx + 1] = screenY;      // pitch -> y pixel coordinate\n"
    "    verticesOut[outIdx + 2] = distance;     // distance -> depth\n"
    "    verticesOut[outIdx + 3] = uv.x;\n"
    "    verticesOut[outIdx + 4] = uv.y;\n"
    "    verticesOut[outIdx + 5] = texIndex;\n"
    "}\n";
