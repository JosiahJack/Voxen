// Compute shader for taking input light, instances, and generating a mesh for
// that light's envelope including only the faces in range of the light.
// TODO: Incorporate generation of quads for shadow extrusions on backsides of
//       each and every tri's edges, one quad (two tris) per edge; without any
//       shared vertices the number of verts will be increased 4fold (2 verts
//       original plus 6 new verts for the quad, no shared verts in my entire
//       render pipeline due to the added overhead of triangle indexing not
//       being worth it for the only 2 or 3% of meshes with smoothed normals.
const char *createLightVolume_computeShader =
    "#version 450\n"
    "layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;\n"

    "struct Instance {\n"
    "    int modelIndex;\n"
    "    int texIndex;\n"
    "    int glowIndex;\n"
    "    int specIndex;\n"
    "    int normIndex;\n"
    "    float posx;\n"
    "    float posy;\n"
    "    float posz;\n"
    "    float sclx;\n"
    "    float scly;\n"
    "    float sclz;\n"
    "    float rotx;\n"
    "    float roty;\n"
    "    float rotz;\n"
    "    float rotw;\n"
    "};\n"

    "layout(std430, binding = 6) readonly buffer ModelVertexOffsets {\n"
    "    uint vertexOffsets[];\n" // Go this many floats into the MasterVertexBuffer to get model i
    "};\n"

    "layout(std430, binding = 7) buffer OutputInRangeFlag {\n" // Resulting light volume mesh comprised of all various meshes data and instance data carried accross same as chunk.glsl
    "    uint outInRange[];\n" // Resulting light volume mesh, ready to feed direct into chunk.glsl fragment shader skipping the vert shader... um wait?  Wut??
    "};\n"

    "layout(std430, binding = 10) buffer InstancesBuffer {\n"
    "    Instance instances[];\n"
    "};\n"

    "layout(std430, binding = 11) buffer InstanceBuffer {\n"
    "    mat4 instanceMatrices[];\n"
    "};\n"

    "layout(std430, binding = 20) readonly buffer MasterVertexBuffer {\n"
    "    float vertexData[];\n" // x, y, z, nx, ny, nz, u, v - Flat Packed all verts all data all mesh types
    "};\n"

    "layout(std430, binding = 21) buffer OutputVertices {\n" // Resulting light volume mesh comprised of all various meshes data and instance data carried accross same as chunk.glsl
    "    float outVertices[];\n" // Resulting light volume mesh, ready to feed direct into chunk.glsl fragment shader skipping the vert shader... um wait?  Wut??
    "};\n"

    "uniform float lightRange;\n"
    "uniform float lightPosX;\n"
    "uniform float lightPosY;\n"
    "uniform float lightPosZ;\n"

    "void main() {\n"
    "    uint globalIdx = gl_GlobalInvocationID.x;\n"
    "    if (globalIdx >= vertexData.length() / 14) return;\n"

    "    uint instanceIdx = globalIdx / (65535);\n" // MAX_VERTS_PER_LIGHT_VOLUME
    "    if (instanceIdx >= instances.length()) return;\n"

    "    uint vertexBase = vertexOffsets[instances[instanceIdx].modelIndex ] + (globalIdx % 65535);\n"
    "    if (vertexBase >= vertexData.length() / 14) return;\n"

    "    uint vertAttribs = 14;\n"
    "    vec3 v = vec3(vertexData[vertexBase * vertAttribs + 0], vertexData[vertexBase * vertAttribs + 1], vertexData[vertexBase * vertAttribs + 2]);\n"
    "    vec3 n = vec3(vertexData[vertexBase * vertAttribs + 3], vertexData[vertexBase * vertAttribs + 4], vertexData[vertexBase * vertAttribs + 5]);\n"
    "    vec2 uv = vec2(vertexData[vertexBase * vertAttribs + 6], vertexData[vertexBase * vertAttribs + 7]);\n"
    "    float texIdx = vertexData[vertexBase * vertAttribs + 8];\n"
    "    float glowIdx = vertexData[vertexBase * vertAttribs + 9];\n"
    "    float specIdx = vertexData[vertexBase * vertAttribs + 10];\n"
    "    float normIdx = vertexData[vertexBase * vertAttribs + 11];\n"
    "    float modelIdx = vertexData[vertexBase * vertAttribs + 12];\n"
    "    float instanceIdxData = vertexData[vertexBase * vertAttribs + 13];\n"

    // Transform to world space
    "    mat4 transform = instanceMatrices[instanceIdx];\n"
    "    v = (transform * vec4(v, 1.0)).xyz;\n"
    "    n = normalize(mat3(transpose(inverse(transform))) * n);\n"
    // Light-local space
    "    vec3 lightPos = vec3(lightPosX, lightPosY, lightPosZ);\n"
    "    vec3 localV = v - lightPos;\n"

    // Distance check
    "    float rangeSq = lightRange * lightRange;\n" 
    "    float d = dot(localV, localV);\n"
    "    uint vertexIdx = globalIdx * vertAttribs;\n"
    "    outInRange[globalIdx] = uint(d <= rangeSq);\n"
    // Write vertex
    "    outVertices[vertexIdx] = v.x;\n"
    "    outVertices[vertexIdx + 1] = v.y;\n"
    "    outVertices[vertexIdx + 2] = v.z;\n"
    "    outVertices[vertexIdx + 3] = n.x;\n"
    "    outVertices[vertexIdx + 4] = n.y;\n"
    "    outVertices[vertexIdx + 5] = n.z;\n"
    "    outVertices[vertexIdx + 6] = uv.x;\n"
    "    outVertices[vertexIdx + 7] = uv.y;\n"
    "    outVertices[vertexIdx + 8]  = float(instances[instanceIdx].texIndex);\n"
    "    outVertices[vertexIdx + 9]  = float(instances[instanceIdx].glowIndex);\n"
    "    outVertices[vertexIdx + 10] = float(instances[instanceIdx].specIndex);\n"
    "    outVertices[vertexIdx + 11] = float(instances[instanceIdx].normIndex);\n"
    "    outVertices[vertexIdx + 12] = float(instances[instanceIdx].modelIndex);\n"
    "    outVertices[vertexIdx + 13] = float(instanceIdx);\n"
    "}\n";
