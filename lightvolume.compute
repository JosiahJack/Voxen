// Compute shader for taking input light, instances, and generating a mesh for
// shadows extruded from edges near the light.
const char *createLightVolume_computeShader =
    "#version 450\n"
    "layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;\n"

    "struct Instance {\n"
    "    int modelIndex;\n"
    "    int texIndex;\n"
    "    int glowIndex;\n"
    "    int specIndex;\n"
    "    int normIndex;\n"
    "    float posx;\n"
    "    float posy;\n"
    "    float posz;\n"
    "    float sclx;\n"
    "    float scly;\n"
    "    float sclz;\n"
    "    float rotx;\n"
    "    float roty;\n"
    "    float rotz;\n"
    "    float rotw;\n"
    "};\n"

    "layout(std430, binding = 6) readonly buffer ModelVertexOffsets {\n"
    "    uint vertexOffsets[];\n"
    "};\n"

    "layout(std430, binding = 8) readonly buffer ModelVertexCounts {\n"
    "    uint modelVertexCounts[];\n"
    "};\n"

    "layout(std430, binding = 10) readonly buffer InstancesBuffer {\n"
    "    Instance instances[];\n"
    "};\n"

    "layout(std430, binding = 11) readonly buffer InstanceBuffer {\n"
    "    mat4 instanceMatrices[];\n"
    "};\n"

    "layout(std430, binding = 20) readonly buffer MasterVertexBuffer {\n"
    "    float vertexData[];\n"
    "};\n"

    "layout(std430, binding = 21) buffer OutputVertices {\n"
    "    float lightVolumeMeshTempVertBuffer[];\n"
    "};\n"

    "layout(binding = 22, offset = 0) uniform atomic_uint headVertIdx;\n"

    "uniform float lightPosX;\n"
    "uniform float lightPosY;\n"
    "uniform float lightPosZ;\n"
    "uniform float lightRange;\n"
    "uniform uint lightIndex;\n"
    "const uint INSTANCE_COUNT = 5500;\n"
    "const uint VERTEX_ATTRIBUTES_COUNT = 14;\n"
    "const uint MAX_LIGHT_VOLUME_MESH_VERTS = 2000000;\n"
    "const float LIGHT_RANGE_MAX_SQUARED = 235.9296;\n" // 15.36f * 15.36f
    "void main() {\n"
    "    if (gl_LocalInvocationID.x == 0) {\n"
    "        headVertIdx = 0;\n"
    "    }\n"

    "    uint instanceIdx = gl_GlobalInvocationID.x;\n"
    "    if (instanceIdx >= INSTANCE_COUNT) return;\n"

    "    Instance inst = instances[instanceIdx];\n"
    "    int modelIdx = inst.modelIndex;\n"
    "    if (modelIdx < 0) return;\n"

    "    uint vertCount = modelVertexCounts[modelIdx];\n"
    "    mat4 matrix = instanceMatrices[instanceIdx];\n"
    "    for (uint vertIdx = 0; (vertIdx < vertCount) && (headVertIdx < MAX_LIGHT_VOLUME_MESH_VERTS - 21); vertIdx += 3) {\n"
        "    vec3 lightPos = vec3(lightPosX, lightPosY, lightPosZ);\n"
        "    float sqrRange = lightRange * lightRange;\n"
        "    vec3 instancePos = vec3(inst.posx, inst.posy, inst.posz);\n"
        "    vec3 diffPos = lightPos - instancePos;\n"
        "    float distSquared_PosToPos = dot(diffPos,diffPos);\n"
        "    if (distSquared_PosToPos > LIGHT_RANGE_MAX_SQUARED) return;\n"

        "    uint vertexIdx = (vertexOffsets[modelIdx] * VERTEX_ATTRIBUTES_COUNT) + (vertIdx * VERTEX_ATTRIBUTES_COUNT);\n"
        "    vec3 world_pos[3];\n"
        "    vec3 world_norm[3];\n"
        "    vec3 model_pos[3];\n"
        "    bool anyInRange = false;\n"
        "    for (uint i = 0; i < 3; ++i) {\n"
        "        model_pos[i] =  vec3(vertexData[vertexIdx + i * VERTEX_ATTRIBUTES_COUNT + 0], vertexData[vertexIdx + i * VERTEX_ATTRIBUTES_COUNT + 1], vertexData[vertexIdx + i * VERTEX_ATTRIBUTES_COUNT + 2]);\n"
        "        world_norm[i] = vec3(vertexData[vertexIdx + i * VERTEX_ATTRIBUTES_COUNT + 3], vertexData[vertexIdx + i * VERTEX_ATTRIBUTES_COUNT + 4], vertexData[vertexIdx + i * VERTEX_ATTRIBUTES_COUNT + 5]);\n"
        "        world_pos[i] = (matrix * vec4(model_pos[i],1.0)).xyz;\n" // mat4_transform_vec3 glsl equivalent
    //     "        world_norm[i] = normalize(mat3(transpose(inverse(matrix))) * world_norm[i]);\n"
        "        vec3 diffWorldPos = lightPos - world_pos[i];\n"
        "        float dist = dot(diffWorldPos,diffWorldPos);\n" // Dot product of a vec3 with itself is squared distance.
        "        if (dist < sqrRange + 0.001) anyInRange = true;\n"
        "    }\n"

        "    if (!anyInRange) continue;\n"
        "    if (headVertIdx + 21 > MAX_LIGHT_VOLUME_MESH_VERTS) break;\n"

         // Output original triangle (3 vertices)
//     "    for (uint i = 0; i < 3; ++i) {\n"
//     "        uint outIdx = outputBase + i * VERTEX_ATTRIBUTES_COUNT;\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 0] = world_pos[i].x;\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 1] = world_pos[i].y;\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 2] = world_pos[i].z;\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 3] = world_norm[i].x;\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 4] = world_norm[i].y;\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 5] = world_norm[i].z;\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 6] = uv[i].x;\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 7] = uv[i].y;\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 8] = float(inst.texIndex);\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 9] = float(inst.glowIndex);\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 10] = float(inst.specIndex);\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 11] = float(inst.normIndex);\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 12] = float(modelIdx);\n"
//     "        lightVolumeMeshTempVertBuffer[outIdx + 13] = float(instanceIdx);\n"
//     "    }\n"

             // Compute triangle centroid and average normal
        "    vec3 triCentroid =        ( world_pos[0] +  world_pos[1] +  world_pos[2]) / 3.0f;\n"
        "    vec3 avg_norm = normalize((world_norm[0] + world_norm[1] + world_norm[2]) / 3.0f);\n"

             // Check if triangle is back-facing relative to light
        "    vec3 light_dir = normalize(lightPos - triCentroid);\n"
        "    if (dot(avg_norm,light_dir) <= 0.0f) continue;\n" // Skip back-facing triangles

        "    for (uint edge = 0; edge < 3; ++edge) {\n"
        "        uint v0_idx = edge;\n"
        "        uint v1_idx = (edge + 1) % 3;\n"

                // Edge direction
        "        vec3 edge_dir = normalize(world_pos[v1_idx] - world_pos[v0_idx]);\n"

                // Compute triangle normal (use v1's normal for both triangles)
        "        vec3 tri_norm = normalize(cross(world_norm[v1_idx], edge_dir));\n"

                // Extrusion directions (v0 and v1 away from light)
        "        vec3 extrude_dir[2];\n"
        "        for (uint i = 0; i < 2; ++i) {\n"
        "            uint idx = (i == 0) ? v0_idx : v1_idx;\n"
        "            extrude_dir[i] = normalize(world_pos[idx] - lightPos) * lightRange;\n"
        "        }\n"

                // Triangle vertices: First triangle (v0, v1, v1_extruded), Second triangle (v1, v1_extruded, v0_extruded)
        "        vec3 tri_verts[4] = {\n"
        "            world_pos[v0_idx],\n"
        "            world_pos[v1_idx],\n"
        "            world_pos[v1_idx] + extrude_dir[1],\n"
        "            world_pos[v0_idx] + extrude_dir[0]\n"
        "        };\n"

                // Write two triangles (6 vertices): (v0, v1, v1_extruded) and (v1, v1_extruded, v0_extruded)
        "        int tri_indices[6] = { 0, 1, 2, 0, 2, 3 };\n" // v0,v1,v1_extruded, then v0, v1_extruded, v0_extruded
        "        for (uint i = 0; i < 6; ++i) {\n"
        "            uint vert = tri_indices[i];\n"
        "            uint workingIdx = headVertIdx * VERTEX_ATTRIBUTES_COUNT;\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 0] = tri_verts[vert].x;\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 1] = tri_verts[vert].y;\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 2] = tri_verts[vert].z;\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 3] = tri_norm.x;\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 4] = tri_norm.y;\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 5] = tri_norm.z;\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 6] = 0.0;\n" // u
        "            lightVolumeMeshTempVertBuffer[workingIdx + 7] = 0.0;\n" // v
        "            lightVolumeMeshTempVertBuffer[workingIdx + 8] = intBitsToFloat(41);\n" // texIndex
        "            lightVolumeMeshTempVertBuffer[workingIdx + 9] = intBitsToFloat(65535);\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 10] = intBitsToFloat(65535);\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 11] = intBitsToFloat(65535);\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 12] = uintBitsToFloat(modelIdx);\n"
        "            lightVolumeMeshTempVertBuffer[workingIdx + 13] = uintBitsToFloat(instanceIdx);\n"
        "            atomicAdd(headVertIdx,1);\n"
        "            memoryBarrierShared();\n"
        "        }\n"
        "    }\n"
    "    }\n"

    "    memoryBarrierShared();\n"
    "    barrier();\n"
    "    if (gl_LocalInvocationID.x == INSTANCE_COUNT) {\n"
    "        vertexCount += headVertIdx;\n"
    "    }\n"
    "}\n";
