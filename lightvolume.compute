// Compute shader for taking input light, instances, and generating a mesh for
// that light's envelope including only the faces in range of the light.
// TODO: Incorporate generation of quads for shadow extrusions on backsides of
//       each and every tri's edges, one quad (two tris) per edge; without any
//       shared vertices the number of verts will be increased 4fold (2 verts
//       original plus 6 new verts for the quad, no shared verts in my entire
//       render pipeline due to the added overhead of triangle indexing not
//       being worth it for the only 2 or 3% of meshes with smoothed normals.
const char *createLightVolume_computeShader =
    "#version 450\n"
    "layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;\n"

    "struct Instance {\n"
    "    int modelIndex;\n"
    "    int texIndex;\n"
    "    int glowIndex;\n"
    "    int specIndex;\n"
    "    int normIndex;\n"
    "    float posx;\n"
    "    float posy;\n"
    "    float posz;\n"
    "    float sclx;\n"
    "    float scly;\n"
    "    float sclz;\n"
    "    float rotx;\n"
    "    float roty;\n"
    "    float rotz;\n"
    "    float rotw;\n"
    "};\n"

    "layout(std430, binding = 10) buffer InstancesBuffer {\n"
    "    Instance instances[];\n"
    "};\n"

    "layout(std430, binding = 11) buffer InstanceBuffer {\n"
    "    mat4 instanceMatrices[];\n"
    "};\n"

    "layout(std430, binding = 20) readonly buffer MasterVertexBuffer {\n"
    "    float vertices[];\n" // x, y, z, nx, ny, nz, u, v - Flat Packed all verts all data all mesh types
    "};\n"

    "layout(std430, binding = 21) buffer OutputVertices {\n" // Resulting light volume mesh comprised of all various meshes data and instance data carried accross same as chunk.glsl
    "    Vertex outVertices[];\n"
    "};\n"

    "uniform float lightRange;\n"
    "uniform float lightPosX;\n"
    "uniform float lightPosY;\n"
    "uniform float lightPosZ;\n"

    "void main() {\n"
    "    uint globalIdx = gl_GlobalInvocationID.x;\n"
    "    uint instanceIdx = globalIdx / (88800 / 3);\n" // ~88,800 verts
    "    uint triIdx = globalIdx % (88800 / 3);\n" // Triangle index
    "    if (instanceIdx >= instances.length() || triIdx * 3 >= instances[instanceIdx].vertexCount) return;\n"

    "    uint vertexBase = instances[instanceIdx].vertexOffset + triIdx * 3;\n"
    "    vec3 v0 = vec3(vertexData[vertexBase * 8 + 0], vertexData[vertexBase * 8 + 1], vertexData[vertexBase * 8 + 2]);\n"
    "    vec3 v1 = vec3(vertexData[(vertexBase + 1) * 8 + 0], vertexData[(vertexBase + 1) * 8 + 1], vertexData[(vertexBase + 1) * 8 + 2]);\n"
    "    vec3 v2 = vec3(vertexData[(vertexBase + 2) * 8 + 0], vertexData[(vertexBase + 2) * 8 + 1], vertexData[(vertexBase + 2) * 8 + 2]);\n"
    "    vec3 n0 = vec3(vertexData[vertexBase * 8 + 3], vertexData[vertexBase * 8 + 4], vertexData[vertexBase * 8 + 5]);\n"
    "    vec3 n1 = vec3(vertexData[(vertexBase + 1) * 8 + 3], vertexData[(vertexBase + 1) * 8 + 4], vertexData[(vertexBase + 1) * 8 + 5]);\n"
    "    vec3 n2 = vec3(vertexData[(vertexBase + 2) * 8 + 3], vertexData[(vertexBase + 2) * 8 + 4], vertexData[(vertexBase + 2) * 8 + 5]);\n"
    "    vec2 uv0 = vec2(vertexData[vertexBase * 8 + 6], vertexData[vertexBase * 8 + 7]);\n"
    "    vec2 uv1 = vec2(vertexData[(vertexBase + 1) * 8 + 6], vertexData[(vertexBase + 1) * 8 + 7]);\n"
    "    vec2 uv2 = vec2(vertexData[(vertexBase + 2) * 8 + 6], vertexData[(vertexBase + 2) * 8 + 7]);\n"

        // Transform to world space
    "    mat4 transform = instances[instanceIdx].transform;
    "    v0 = (transform * vec4(v0, 1.0)).xyz;\n"
    "    v1 = (transform * vec4(v1, 1.0)).xyz;\n"
    "    v2 = (transform * vec4(v2, 1.0)).xyz;\n"
    "    n0 = normalize((transform * vec4(n0, 0.0)).xyz);\n"
    "    n1 = normalize((transform * vec4(n1, 0.0)).xyz);\n"
    "    n2 = normalize((transform * vec4(n2, 0.0)).xyz);\n"

        // Light-local space
    "    vec3 localV0 = v0 - light.position;\n"
    "    vec3 localV1 = v1 - light.position;\n"
    "    vec3 localV2 = v2 - light.position;\n"

        // Distance check
    "    float rangeSq = light.range * light.range;\n"
    "    float d0 = dot(localV0, localV0);\n"
    "    float d1 = dot(localV1, localV1);\n"
    "    float d2 = dot(localV2, localV2);\n"
    "    if (d0 > rangeSq && d1 > rangeSq && d2 > rangeSq) return;\n"

        // Compute tangents/bitangents
    "    vec3 edge1 = v1 - v0, edge2 = v2 - v0;\n"
    "    vec2 deltaUV1 = uv1 - uv0, deltaUV2 = uv2 - uv0;\n"
    "    float f = 1.0 / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y + 0.0001);\n"
    "    vec3 tangent = normalize(f * (deltaUV2.y * edge1 - deltaUV1.y * edge2));\n"
    "    vec3 bitangent = normalize(f * (-deltaUV2.x * edge1 + deltaUV1.x * edge2));\n"

        // Reserve space (1 source tri + 3 quads = 7 triangles, 3 source + 6 extruded vertices)
    "    uint vertexIdx = atomicAdd(vertexCounter, 9);\n"
    "    uint indexIdx = atomicAdd(indexCounter, 7 * 3);\n"

        // Write source triangle
    "    outVertices[vertexIdx] = Vertex(v0, n0, uv0, tangent, bitangent,\n"
    "        instances[instanceIdx].texIndex, instances[instanceIdx].glowIndex,\n"
    "        instances[instanceIdx].specIndex, instances[instanceIdx].normIndex,\n"
    "        instanceIdx, 0);\n"
    "    outVertices[vertexIdx + 1] = Vertex(v1, n1, uv1, tangent, bitangent,\n"
    "        instances[instanceIdx].texIndex, instances[instanceIdx].glowIndex,\n"
    "        instances[instanceIdx].specIndex, instances[instanceIdx].normIndex,\n"
    "        instanceIdx, 0);\n"
    "    outVertices[vertexIdx + 2] = Vertex(v2, n2, uv2, tangent, bitangent,\n"
    "        instances[instanceIdx].texIndex, instances[instanceIdx].glowIndex,\n"
    "        instances[instanceIdx].specIndex, instances[instanceIdx].normIndex,\n"
    "        instanceIdx, 0);\n"
    "    outIndices[indexIdx + 0] = vertexIdx;\n"
    "    outIndices[indexIdx + 1] = vertexIdx + 1;\n"
    "    outIndices[indexIdx + 2] = vertexIdx + 2;\n"

        // Triangle center for outward normal
    "    vec3 triCenter = (v0 + v1 + v2) / 3.0;\n"

        // Edge 0-1
    "    vec3 e0v0 = normalize(localV0) * light.range;\n"
    "    vec3 e0v1 = normalize(localV1) * light.range;\n"
    "    vec3 edge = v1 - v0;\n"
    "    vec3 extrudeDir = (e0v0 + e0v1) * 0.5;\n"
    "    vec3 normal = normalize(cross(extrudeDir, edge));\n"
    "    if (dot(normal, triCenter - v0) > 0.0) normal = -normal;\n"
    "    outVertices[vertexIdx + 3] = Vertex(v0 + e0v0 + light.position, normal, uv0, tangent, bitangent,\n"
    "        65534, 65534, 65534, 65534, instanceIdx, 1);\n"
    "    outVertices[vertexIdx + 4] = Vertex(v1 + e0v1 + light.position, normal, uv1, tangent, bitangent,\n"
    "        65534, 65534, 65534, 65534, instanceIdx, 1);\n"
    "    outIndices[indexIdx + 3] = vertexIdx + 3;\n"
    "    outIndices[indexIdx + 4] = vertexIdx + 4;\n"
    "    outIndices[indexIdx + 5] = vertexIdx;\n"
    "    outIndices[indexIdx + 6] = vertexIdx + 4;\n"
    "    outIndices[indexIdx + 7] = vertexIdx + 1;\n"
    "    outIndices[indexIdx + 8] = vertexIdx + 3;\n"

        // Edge 1-2
    "    vec3 e1v1 = normalize(localV1) * light.range;\n"
    "    vec3 e1v2 = normalize(localV2) * light.range;\n"
    "    edge = v2 - v1;\n"
    "    extrudeDir = (e1v1 + e1v2) * 0.5;\n"
    "    normal = normalize(cross(extrudeDir, edge));\n"
    "    if (dot(normal, triCenter - v1) > 0.0) normal = -normal;\n"
    "    outVertices[vertexIdx + 5] = Vertex(v1 + e1v1 + light.position, normal, uv1, tangent, bitangent,\n"
    "        65534, 65534, 65534, 65534, instanceIdx, 1);\n"
    "    outVertices[vertexIdx + 6] = Vertex(v2 + e1v2 + light.position, normal, uv2, tangent, bitangent,\n"
    "        65534, 65534, 65534, 65534, instanceIdx, 1);\n"
    "    outIndices[indexIdx + 9] = vertexIdx + 5;\n"
    "    outIndices[indexIdx + 10] = vertexIdx + 6;\n"
    "    outIndices[indexIdx + 11] = vertexIdx + 1;\n"
    "    outIndices[indexIdx + 12] = vertexIdx + 6;\n"
    "    outIndices[indexIdx + 13] = vertexIdx + 2;\n"
    "    outIndices[indexIdx + 14] = vertexIdx + 5;\n"

        // Edge 2-0
    "    vec3 e2v2 = normalize(localV2) * light.range;\n"
    "    vec3 e2v0 = normalize(localV0) * light.range;\n"
    "    edge = v0 - v2;\n"
    "    extrudeDir = (e2v2 + e2v0) * 0.5;\n"
    "    normal = normalize(cross(extrudeDir, edge));\n"
    "    if (dot(normal, triCenter - v2) > 0.0) normal = -normal;\n"
    "    outVertices[vertexIdx + 7] = Vertex(v2 + e2v2 + light.position, normal, uv2, tangent, bitangent,\n"
    "        65534, 65534, 65534, 65534, instanceIdx, 1);\n"
    "    outVertices[vertexIdx + 8] = Vertex(v0 + e2v0 + light.position, normal, uv0, tangent, bitangent,\n"
    "        65534, 65534, 65534, 65534, instanceIdx, 1);\n"
    "    outIndices[indexIdx + 15] = vertexIdx + 7;\n"
    "    outIndices[indexIdx + 16] = vertexIdx + 8;\n"
    "    outIndices[indexIdx + 17] = vertexIdx + 2;\n"
    "    outIndices[indexIdx + 18] = vertexIdx + 8;\n"
    "    outIndices[indexIdx + 19] = vertexIdx;\n"
    "    outIndices[indexIdx + 20] = vertexIdx + 7;\n"
    "}\n";
