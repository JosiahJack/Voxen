const char *deferredLighting_computeShader =
    "#version 450 core\n"
    "\n"
    "layout(local_size_x = 8, local_size_y = 8) in;\n"
    "\n"
    "layout(rgba8, binding = 0) uniform image2D inputImage;\n"
    "layout(rgba8, binding = 1) uniform image2D inputNormals;\n"
    "layout(rgba8, binding = 2) uniform image2D inputDepth;\n"
    "layout(rgba8, binding = 3) uniform image2D outputImage;\n"
    "\n"
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"
    "uniform mat4 invViewProj;\n" // Inverse view-projection matrix to reconstruct world position
    "\n"
    "struct LightData {\n"
    "    vec3 position;\n"
    "    float intensity;\n"
    "    float radius;\n"
    "    float spotAng;\n" // In degrees, 0 for point lights
    "    vec3 spotDir;\n"
    "};\n"
    "layout(std430, binding = 1) buffer LightBuffer {\n"
    "    LightData lights[];\n"
    "};\n"
    "\n"
    "void main() {\n"
    "    uvec2 pixel = gl_GlobalInvocationID.xy;\n"
    "    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;\n"
    "\n"
    "    // Read G-buffer data\n"
    "    vec4 color = imageLoad(inputImage, ivec2(pixel));\n"
    "    vec3 normal = normalize(imageLoad(inputNormals, ivec2(pixel)).xyz * 2.0 - 1.0);\n"
    "    float depth = imageLoad(inputDepth, ivec2(pixel)).r;\n"
    "\n"
    "    // Reconstruct world position from depth\n"
    "    vec2 uv = vec2(float(pixel.x) / float(screenWidth), float(pixel.y) / float(screenHeight));\n"
    "    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);\n"
    "    vec4 worldPos = invViewProj * clipPos;\n"
    "    worldPos /= worldPos.w;\n"
    "\n"
    "    vec3 lighting = vec3(0.0);\n"
    "    for (int i = 0; i < lights.length(); i++) {\n"
    "        LightData light = lights[i];\n"
    "        vec3 toLight = light.position - worldPos.xyz;\n"
    "        float dist = length(toLight);\n"
    "\n"
    "        // Distance attenuation\n"
    "        if (dist > light.radius) continue;\n"
    "        float attenuation = 1.0 / (1.0 + 0.1 * dist + 0.01 * dist * dist);\n"
    "        vec3 lightDir = normalize(toLight);\n"
    "\n"
    "        // Spot light check\n"
    "        float intensity = light.intensity * attenuation;\n"
    "        if (light.spotAng > 0.0) {\n"
    "            float cosAngle = dot(lightDir, normalize(-light.spotDir));\n"
    "            float spotAngleRad = radians(light.spotAng);\n"
    "            float cosSpotAngle = cos(spotAngleRad);\n"
    "            if (cosAngle < cosSpotAngle) continue;\n"
    "            float spotAttenuation = clamp((cosAngle - cosSpotAngle) / (1.0 - cosSpotAngle), 0.0, 1.0);\n"
    "            intensity *= spotAttenuation;\n"
    "        }\n"
    "\n"
    "        // Diffuse lighting\n"
    "        float diffuse = max(dot(normal, lightDir), 0.0);\n"
    "        lighting += color.rgb * diffuse * intensity;\n"
    "    }\n"
    "\n"
    "    // Write to output image\n"
    "    imageStore(outputImage, ivec2(pixel), vec4(lighting, color.a));\n"
    "}\n";
