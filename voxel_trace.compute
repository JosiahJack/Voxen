// voxel_trace.compute
// Compute shader for tracing against voxels for shadows
const char* voxelTrace_computeShader =
    "#version 450 core\n"
    "layout(local_size_x = 32, local_size_y = 32) in;\n"

    "layout(rgba32f, binding = 1) readonly uniform image2D inputWorldPos;\n"
    "layout(rgba32f, binding = 2) readonly uniform image2D inputNormals;\n"
    "layout(std430, binding = 19) buffer LightIndices { float lights[]; };\n"
    "layout(std430, binding = 26) buffer VoxelLightListIndices { uint voxelLightListIndices[]; };\n"
    "layout(std430, binding = 27) buffer UniqueLightLists { uint uniqueLightLists[]; };\n"

    "layout(binding = 5, r8) writeonly uniform image2D shadowOcclusion;\n" // Quarter-res output (0=lit, 1=shadowed)

    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"
    "uniform vec3 camPos;\n"
    "uniform float worldMin_x;\n"
    "uniform float worldMin_z;\n"
    "uniform sampler2D voxelOpacity;\n"  // XZ 2D texture (R8, 1=opaque voxel)
    "const int SSR_RES = 4;\n"
    "const float VOXEL_SIZE = 0.32;\n"
    "const float WORLDCELL_WIDTH_F = 2.56;\n"
    "const uint VOXEL_GRID_SIZE = 512;\n" // 64*8
    "const float CONE_APERTURE = 0.1;\n"
    "const int MAX_STEPS = 16;\n"
    "const int MAX_LIGHTS = 32;\n"

    "vec2 worldToVoxelXZ(vec3 worldPos) {\n"
    "    float offsetX = worldPos.x - worldMin_x;\n"
    "    float offsetZ = worldPos.z - worldMin_z;\n"
    "    return vec2(offsetX / VOXEL_SIZE, offsetZ / VOXEL_SIZE);\n"  // [0,512]
    "}\n"

    "float traceConeXZ(vec3 startPos, vec3 lightPos, float maxDist) {\n"
    "    vec3 toLight = lightPos - startPos;\n"
    "    float dist = length(toLight);\n"
    "    if (dist > maxDist) return 0.0;\n"
    "    vec3 dir = normalize(toLight);\n"
    "    vec2 startXZ = worldToVoxelXZ(startPos);\n"
    "    vec2 stepXZ = vec2(dir.x, dir.z) * (VOXEL_SIZE / VOXEL_SIZE);\n"  // Normalize to texels
    "    float coneRadius = 0.5;\n" // Start small
    "    float occlusion = 0.0;\n"
    "    float stepLen = dist / float(MAX_STEPS);\n"
    "    for (int i = 0; i < MAX_STEPS; ++i) {\n"
    "        float t = float(i) * stepLen;\n"
    "        vec3 rayPos = startPos + dir * t;\n"
    "        vec2 rayXZ = worldToVoxelXZ(rayPos);\n"

             // Sample cone: Average opacity in circle (approx 4 samples for perf)
    "        float avgOpacity = 0.0;\n"
    "        for (float a = 0.0; a < 6.28; a += 1.57) {\n" // 4 angles
    "            vec2 offset = vec2(cos(a), sin(a)) * coneRadius;\n"
    "            vec2 sampleXZ = rayXZ + offset;\n"
    "            sampleXZ = clamp(sampleXZ / float(VOXEL_GRID_SIZE), 0.0, 1.0);\n"
    "            avgOpacity += texture(voxelOpacity, sampleXZ).r;\n"
    "        }\n"
    "        avgOpacity /= 4.0;\n"
    "        occlusion += avgOpacity;\n"
    "        coneRadius += CONE_APERTURE * stepLen;\n" // Widen cone
    "        if (occlusion > 0.99) break;\n" // Early out
    "    }\n"
    "    return clamp(occlusion / float(MAX_STEPS), 0.0, 1.0);\n" // Normalized shadow factor
    "}\n"

    "uint GetVoxelIndexXZ(vec3 worldPos) {\n" // Reuse/modify your func, ignore Y
    "    float offsetX = worldPos.x - worldMin_x + (VOXEL_SIZE * 0.5);\n"
    "    float offsetZ = worldPos.z - worldMin_z + (VOXEL_SIZE * 0.5);\n"
    "    uint cellX = uint(offsetX / WORLDCELL_WIDTH_F);\n"
    "    uint cellZ = uint(offsetZ / WORLDCELL_WIDTH_F);\n"
    "    float localX = mod(offsetX, WORLDCELL_WIDTH_F);\n"
    "    float localZ = mod(offsetZ, WORLDCELL_WIDTH_F);\n"
    "    uint voxelX = uint(localX / VOXEL_SIZE);\n"
    "    uint voxelZ = uint(localZ / VOXEL_SIZE);\n"
    "    uint cellIndex = cellZ * 64 + cellX;\n"
    "    return cellIndex * 64 + voxelZ * 8 + voxelX;\n" // Flatten to 1D for lists
    "}\n"

    "void main() {\n"
    "    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy * SSR_RES);\n"  // Full-res trace, but output quarter
    "    if (pixel.x >= int(screenWidth) || pixel.y >= int(screenHeight)) return;\n"

    "    vec4 worldPosPack = imageLoad(inputWorldPos, pixel);\n"
    "    vec3 worldPos = worldPosPack.xyz;\n"
    "    vec2 normalXY = unpackHalf2x16(floatBitsToInt(imageLoad(inputNormals, pixel).r));\n"
    "    vec2 normalZ0 = unpackHalf2x16(floatBitsToInt(imageLoad(inputNormals, pixel).g));\n"
    "    vec3 normal = normalize(vec3(normalXY, normalZ0.x));\n"
    "    if (length(normal) < 0.01) {\n" // Sky/empty
    "        imageStore(shadowOcclusion, ivec2(gl_GlobalInvocationID.xy), vec4(0.0));\n"
    "        return;\n"
    "    }\n"

    "    uint voxelIdx = GetVoxelIndexXZ(worldPos);\n"
    "    uint count = voxelLightListIndices[voxelIdx * 2 + 1];\n"
    "    float totalOcclusion = 0.0;\n"
    "    uint listOffset = voxelLightListIndices[voxelIdx * 2];\n"

    "    for (uint i = 0; i < min(count, MAX_LIGHTS); ++i) {\n"
    "        uint lightIdx = uniqueLightLists[listOffset + i] * 13u;\n" // LIGHT_DATA_SIZE=13
    "        vec3 lightPos = vec3(lights[lightIdx + 0], lights[lightIdx + 1], lights[lightIdx + 2]);\n"
    "        float range = lights[lightIdx + 4];\n"
    "        float intensity = lights[lightIdx + 3];\n"
    "        if (intensity < 0.05) continue;\n"

    "        vec3 toLight = lightPos - worldPos;\n"
    "        float distToLight = length(toLight);\n"
    "        if (distToLight > range || distToLight < 0.01) continue;\n"

    "        vec3 lightDir = normalize(toLight);\n"
    "        float NdotL = max(dot(normal, lightDir), 0.0);\n"
    "        if (NdotL < 0.25) continue;\n" // Backface culling

    "        float occ = traceConeXZ(worldPos, lightPos, range);\n"
    "        totalOcclusion += occ * NdotL;\n" // Weight by direct contrib
    "    }\n"
    "    float avgOcclusion = count > 0 ? (totalOcclusion / float(count)) : 0.0;\n"
    "    imageStore(shadowOcclusion, ivec2(gl_GlobalInvocationID.xy), vec4(avgOcclusion));\n" // Per-light avg or max; tune
    "}\n";
