// imageblit.glsl
// Full screen quad unlit textured for presenting image buffers such as results
// from compute shaders, image effects, post-processing, etc..
const char *quadVertexShaderSource =
    "#version 450 core\n"
    "layout(location = 0) in vec2 aPos;\n"
    "layout(location = 1) in vec2 aTexCoord;\n"
    "out vec2 TexCoord;\n"
    "void main() {\n"
    "    gl_Position = vec4(aPos, 0.0, 1.0);\n"
    "    TexCoord = aTexCoord;\n"
    "}\n";

// const char* quadFragmentShaderSource =
//     "#version 450 core\n"
//     "in vec2 TexCoord;\n"
//     "out vec4 FragColor;\n"
//     "uniform sampler2D tex;\n"
//     "uniform int debugView;\n"
//     "uniform int debugValue;\n"
//     "uniform uint screenWidth;\n"
//     "uniform uint screenHeight;\n"
//     "layout(rgba32f, binding = 4) uniform image2D outputImage;\n"
// 
//     "void main() {\n"
//     "    FragColor = texture(tex, TexCoord);\n"
//     "    if (debugView == 0) {\n"
//     "        ivec2 pixel = ivec2(TexCoord * vec2(screenWidth/2, screenHeight/2));\n"
//     "        vec4 reflectionColor = vec4(0.0);\n"
//     "        float weights[9] = float[](0.1, 0.1, 0.1, 0.1, 0.2, 0.1, 0.1, 0.1, 0.1);\n"
//     "        ivec2 offsets[9] = ivec2[](\n"
//     "            ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1),\n"
//     "            ivec2(-1,  0), ivec2(0,  0), ivec2(1,  0),\n"
//     "            ivec2(-1,  1), ivec2(0,  1), ivec2(1,  1)\n"
//     "        );\n"
//     "        for (int i = 0; i < 9; ++i) {\n"
//     "            ivec2 samplePixel = pixel + offsets[i];\n"
//     "            samplePixel = clamp(samplePixel, ivec2(0), ivec2(int(screenWidth/2)-1, int(screenHeight/2)-1));\n"
//     "            reflectionColor += imageLoad(outputImage, samplePixel) * weights[i];\n"
//     "        }\n"
//     "        FragColor += reflectionColor;\n"
//     "    } else if (debugView == 7 || debugView == 10) {\n"
//     "        FragColor = imageLoad(outputImage, ivec2(TexCoord * vec2(screenWidth/2, screenHeight/2)));\n"
//     "    }\n"
//     "}\n";

// const char* quadFragmentShaderSource =
//     "#version 450 core\n"
//     "in vec2 TexCoord;\n"
//     "out vec4 FragColor;\n"
//     "uniform sampler2D tex;\n"
//     "uniform int debugView;\n"
//     "uniform int debugValue;\n"
//     "uniform uint screenWidth;\n"
//     "uniform uint screenHeight;\n"
//     "layout(rgba32f, binding = 4) uniform image2D outputImage;\n"
// 
//     "float hash(vec2 p) {\n"
//     "    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n"
//     "}\n"
// 
//     "void main() {\n"
//     "    FragColor = texture(tex, TexCoord);\n"
//     "    if (debugView == 0) {\n"
//     "        vec2 pixelSize = vec2(1.0 / (screenWidth/2), 1.0 / (screenHeight/2));\n"
//     "        vec2 jitter = vec2(hash(TexCoord + vec2(debugValue)) - 0.5, hash(TexCoord + vec2(debugValue + 1.0)) - 0.5) * pixelSize;\n"
//     "        ivec2 pixel = ivec2((TexCoord + jitter) * vec2(screenWidth/2, screenHeight/2));\n"
//     "        pixel = clamp(pixel, ivec2(0), ivec2(int(screenWidth/2)-1, int(screenHeight/2)-1));\n"
//     "        vec4 reflectionColor = imageLoad(outputImage, pixel);\n"
//     "        FragColor += reflectionColor;\n"
//     "    } else if (debugView == 7 || debugView == 10) {\n"
//     "        FragColor = imageLoad(outputImage, ivec2(TexCoord * vec2(screenWidth/2, screenHeight/2)));\n"
//     "    }\n"
//     "}\n";

// const char* quadFragmentShaderSource =
//     "#version 450 core\n"
//     "in vec2 TexCoord;\n"
//     "out vec4 FragColor;\n"
//     "uniform sampler2D tex;\n"
//     "uniform int debugView;\n"
//     "uniform int debugValue;\n"
//     "uniform uint screenWidth;\n"
//     "uniform uint screenHeight;\n"
//     "layout(rgba32f, binding = 4) uniform image2D outputImage;\n"
//     "layout(rgba32f, binding = 2) readonly uniform image2D inputNormals;\n"
// 
//     "vec3 unpackNormal(vec4 normalPack) {\n"
//     "    vec2 normalXY = unpackHalf2x16(floatBitsToInt(normalPack.r));\n"
//     "    vec2 normalZ0 = unpackHalf2x16(floatBitsToInt(normalPack.g));\n"
//     "    return normalize(vec3(normalXY.x, normalXY.y, normalZ0.x));\n"
//     "}\n"
// 
//     "float hash(vec2 p) {\n"
//     "    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n"
//     "}\n"
// 
//     "void main() {\n"
//     "    FragColor = texture(tex, TexCoord);\n"
//     "    if (debugView == 0) {\n"
//     "        ivec2 pixel = ivec2(TexCoord * vec2(screenWidth, screenHeight));\n"
//     "        vec4 centerNormalPack = imageLoad(inputNormals, pixel);\n"
//     "        vec3 centerNormal = unpackNormal(centerNormalPack);\n"
//     "        float normalDiff = 0.0;\n"
//     "        ivec2 offsets[4] = ivec2[](ivec2(-1, 0), ivec2(1, 0), ivec2(0, -1), ivec2(0, 1));\n"
//     "        for (int i = 0; i < 4; ++i) {\n"
//     "            ivec2 samplePixel = pixel + offsets[i];\n"
//     "            samplePixel = clamp(samplePixel, ivec2(0), ivec2(int(screenWidth)-1, int(screenHeight)-1));\n"
//     "            vec3 neighborNormal = unpackNormal(imageLoad(inputNormals, samplePixel));\n"
//     "            normalDiff = max(normalDiff, length(centerNormal - neighborNormal));\n"
//     "        }\n"
//     "        vec4 reflectionColor = vec4(0.0);\n"
//     "        ivec2 reflPixel = ivec2(TexCoord * vec2(screenWidth/2, screenHeight/2));\n"
//     "        if (normalDiff > 0.05) {\n" // Blur in high-variation areas
//     "            float weights[9] = float[](0.1, 0.1, 0.1, 0.1, 0.2, 0.1, 0.1, 0.1, 0.1);\n"
//     "            ivec2 blurOffsets[9] = ivec2[](\n"
//     "                ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1),\n"
//     "                ivec2(-1,  0), ivec2(0,  0), ivec2(1,  0),\n"
//     "                ivec2(-1,  1), ivec2(0,  1), ivec2(1,  1)\n"
//     "            );\n"
//     "            for (int i = 0; i < 9; ++i) {\n"
//     "                ivec2 samplePixel = reflPixel + blurOffsets[i];\n"
//     "                samplePixel = clamp(samplePixel, ivec2(0), ivec2(int(screenWidth/2)-1, int(screenHeight/2)-1));\n"
//     "                reflectionColor += imageLoad(outputImage, samplePixel) * weights[i];\n"
//     "            }\n"
//     "        } else {\n" // Jitter in smooth areas
//     "            vec2 pixelSize = vec2(1.0 / (screenWidth/2), 1.0 / (screenHeight/2));\n"
//     "            vec2 jitter = vec2(hash(TexCoord + vec2(debugValue)) - 0.5, hash(TexCoord + vec2(debugValue + 1.0)) - 0.5) * pixelSize;\n"
//     "            ivec2 jitterPixel = ivec2((TexCoord + jitter) * vec2(screenWidth/2, screenHeight/2));\n"
//     "            jitterPixel = clamp(jitterPixel, ivec2(0), ivec2(int(screenWidth/2)-1, int(screenHeight/2)-1));\n"
//     "            reflectionColor = imageLoad(outputImage, jitterPixel);\n"
//     "        }\n"
//     "        FragColor += reflectionColor;\n"
//     "    } else if (debugView == 7 || debugView == 10) {\n"
//     "        FragColor = imageLoad(outputImage, ivec2(TexCoord * vec2(screenWidth/2, screenHeight/2)));\n"
//     "    }\n"
//     "}\n";

const char* quadFragmentShaderSource =
    "#version 450 core\n"
    "in vec2 TexCoord;\n"
    "out vec4 FragColor;\n"
    "uniform sampler2D tex;\n"
    "uniform int debugView;\n"
    "uniform int debugValue;\n"
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"
    "layout(rgba32f, binding = 4) uniform image2D outputImage;\n"
    "layout(rgba32f, binding = 2) readonly uniform image2D inputNormals;\n"

    "vec3 unpackNormal(vec4 normalPack) {\n"
    "    vec2 normalXY = unpackHalf2x16(floatBitsToInt(normalPack.r));\n"
    "    vec2 normalZ0 = unpackHalf2x16(floatBitsToInt(normalPack.g));\n"
    "    return normalize(vec3(normalXY.x, normalXY.y, normalZ0.x));\n"
    "}\n"

    // Perlin noise implementation
    "vec2 fade(vec2 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n"
    "float grad(int hash, vec2 p) {\n"
    "    int h = hash & 15;\n"
    "    float u = h < 8 ? p.x : p.y;\n"
    "    float v = h < 4 ? p.y : h == 12 || h == 14 ? p.x : 0.0;\n"
    "    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n"
    "}\n"
    "float perlin(vec2 p) {\n"
    "    ivec2 pi = ivec2(floor(p));\n"
    "    vec2 pf = p - vec2(pi);\n"
    "    ivec2 m = pi & 255;\n"
    "    vec2 f = fade(pf);\n"
    "    int a = (m.x + m.y * 256) % 512;\n"
    "    int b = ((m.x + 1) + m.y * 256) % 512;\n"
    "    int c = (m.x + (m.y + 1) * 256) % 512;\n"
    "    int d = ((m.x + 1) + (m.y + 1) * 256) % 512;\n"
    "    return mix(\n"
    "        mix(grad(a, pf), grad(b, pf - vec2(1.0, 0.0)), f.x),\n"
    "        mix(grad(c, pf - vec2(0.0, 1.0)), grad(d, pf - vec2(1.0, 1.0)), f.x),\n"
    "        f.y) * 0.5 + 0.5;\n"
    "}\n"

    "void main() {\n"
    "    FragColor = texture(tex, TexCoord);\n"
    "    vec4 reflectionColor = vec4(0.0);\n"
    "    if (debugView == 0 || debugView == 7) {\n"
    "        ivec2 pixel = ivec2(TexCoord * vec2(screenWidth, screenHeight));\n"
    "        vec4 centerNormalPack = imageLoad(inputNormals, pixel);\n"
    "        vec3 centerNormal = unpackNormal(centerNormalPack);\n"
    "        float normalDiff = 0.0;\n"
    "        ivec2 offsets[4] = ivec2[](ivec2(-1, 0), ivec2(1, 0), ivec2(0, -1), ivec2(0, 1));\n"
    "        for (int i = 0; i < 4; ++i) {\n"
    "            ivec2 samplePixel = pixel + offsets[i];\n"
    "            samplePixel = clamp(samplePixel, ivec2(0), ivec2(int(screenWidth)-1, int(screenHeight)-1));\n"
    "            vec3 neighborNormal = unpackNormal(imageLoad(inputNormals, samplePixel));\n"
    "            normalDiff = max(normalDiff, length(centerNormal - neighborNormal));\n"
    "        }\n"

    "        ivec2 reflPixel = ivec2(TexCoord * vec2(screenWidth/2, screenHeight/2));\n"
    "        if (normalDiff > 0.05) {\n" // 5x5 Gaussian blur in high-variation areas
    "            float weights[25] = float[](\n"
    "                0.003, 0.013, 0.021, 0.013, 0.003,\n"
    "                0.013, 0.059, 0.097, 0.059, 0.013,\n"
    "                0.021, 0.097, 0.159, 0.097, 0.021,\n"
    "                0.013, 0.059, 0.097, 0.059, 0.013,\n"
    "                0.003, 0.013, 0.021, 0.013, 0.003\n"
    "            );\n"
    "            ivec2 blurOffsets[25] = ivec2[](\n"
    "                ivec2(-2,-2), ivec2(-1,-2), ivec2(0,-2), ivec2(1,-2), ivec2(2,-2),\n"
    "                ivec2(-2,-1), ivec2(-1,-1), ivec2(0,-1), ivec2(1,-1), ivec2(2,-1),\n"
    "                ivec2(-2, 0), ivec2(-1, 0), ivec2(0, 0), ivec2(1, 0), ivec2(2, 0),\n"
    "                ivec2(-2, 1), ivec2(-1, 1), ivec2(0, 1), ivec2(1, 1), ivec2(2, 1),\n"
    "                ivec2(-2, 2), ivec2(-1, 2), ivec2(0, 2), ivec2(1, 2), ivec2(2, 2)\n"
    "            );\n"
    "            for (int i = 0; i < 25; ++i) {\n"
    "                ivec2 samplePixel = reflPixel + blurOffsets[i];\n"
    "                samplePixel = clamp(samplePixel, ivec2(0), ivec2(int(screenWidth/2)-1, int(screenHeight/2)-1));\n"
    "                reflectionColor += imageLoad(outputImage, samplePixel) * weights[i];\n"
    "            }\n"
    "        } else {\n" // Perlin noise jitter in smooth areas
    "            vec2 pixelSize = vec2(1.0 / (screenWidth/2), 1.0 / (screenHeight/2));\n"
    "            vec2 scaledUV = TexCoord * vec2(screenWidth/64.0, screenHeight/64.0) + vec2(debugValue * 0.1);\n"
    "            vec2 jitter = vec2(perlin(scaledUV), perlin(scaledUV + vec2(1.0))) - 0.5;\n"
    "            jitter *= pixelSize;\n"
    "            ivec2 jitterPixel = ivec2((TexCoord + jitter) * vec2(screenWidth/2, screenHeight/2));\n"
    "            jitterPixel = clamp(jitterPixel, ivec2(0), ivec2(int(screenWidth/2)-1, int(screenHeight/2)-1));\n"
    "            reflectionColor = imageLoad(outputImage, jitterPixel);\n"
    "        }\n"

    "        if (debugView == 7) FragColor = reflectionColor;\n"
    "        else FragColor += reflectionColor;\n"
    "    }\n"
    "}\n";
