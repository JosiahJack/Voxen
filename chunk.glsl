// chunk.glsl
// Generic shader for unlit textured surfaces (all world geometry, items,
// enemies, doors, etc., without transparency for first pass prior to lighting.
const char *vertexShaderSource =
    "#version 450 core\n"
    "\n"
    "layout(location = 0) in vec3 aPos;\n"
    "layout(location = 1) in vec3 aNormal;\n"
    "layout(location = 2) in vec2 aTexCoord;\n"
    "layout(location = 3) in float aTexIndex;\n"
    "\n"
    "out vec3 FragPos;\n"
    "out vec3 Normal;\n"
    "out vec2 TexCoord;\n"
    "out float TexIndex;\n"
    "\n"
    "uniform vec3 cameraPos;\n"
    "uniform float yawMin, yawMax, pitchMin, pitchMax;\n"
    "\n"
    "struct InstanceData {\n"
        " vec3 position;\n"
        " vec4 rotation;\n"
        " vec3 scale;\n"
        " int modelIndex;\n"
    "};\n"
    "layout(std430, binding = 1) buffer InstanceBuffer {\n"
        " InstanceData instances[3];\n"
    "};\n"
    "layout(std430, binding = 4) buffer InstanceIDBuffer {\n"
        " uint instanceIDs[];\n"
    "};\n"
    "\n"
    "mat4 quat_to_mat4(vec4 q) {\n"
        " float xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n"
        " float xy = q.x * q.y, xz = q.x * q.z, yz = q.y * q.z;\n"
        " float wx = q.w * q.x, wy = q.w * q.y, wz = q.w * q.z;\n"
        " return mat4(\n"
        " 1.0 - 2.0 * (yy + zz), 2.0 * (xy - wz), 2.0 * (xz + wy), 0.0,\n"
        " 2.0 * (xy + wz), 1.0 - 2.0 * (xx + zz), 2.0 * (yz - wx), 0.0,\n"
        " 2.0 * (xz - wy), 2.0 * (yz + wx), 1.0 - 2.0 * (xx + yy), 0.0,\n"
        " 0.0, 0.0, 0.0, 1.0\n"
        " );\n"
    "}\n"
    "\n"
    "void main() {\n"
        " uint instanceID = instanceIDs[gl_InstanceID];\n"
        " InstanceData inst = instances[instanceID];\n"
        " vec3 pos = inst.position;\n"
        " vec4 rot = inst.rotation;\n"
        " vec3 scl = inst.scale;\n"
        " mat4 rotation = quat_to_mat4(rot);\n"
        " mat4 model = mat4(1.0);\n"
        " model[0][0] = scl.x; model[1][1] = scl.y; model[2][2] = scl.z;\n"
        " model *= rotation;\n"
        " model[3] = vec4(pos, 1.0);\n"
        "\n"
        " // World space position\n"
        " vec3 worldPos = vec3(model * vec4(aPos, 1.0));\n"
        " FragPos = worldPos;\n"
        " Normal = mat3(transpose(inverse(model))) * aNormal;\n"
        " TexCoord = aTexCoord;\n"
        " TexIndex = aTexIndex;\n"
        "\n"
        " // Polar coordinates\n"
        " vec3 toVertex = worldPos - cameraPos;\n"
        " float distance = length(toVertex);\n"
        " if (distance < 0.001) distance = 0.001;\n"
        " vec3 norm = toVertex / distance;\n"
        " float yaw = atan(norm.z, norm.x);\n"
        " float pitch = asin(norm.y);\n"
        "\n"
        " // Map to screen space [0,1]\n"
        " float yawNorm = (yaw - yawMin) / (yawMax - yawMin);\n"
        " float pitchNorm = (pitch - pitchMin) / (pitchMax - pitchMin);\n"
        "\n"
        " // Clip space: x = yaw, y = pitch, z = depth\n"
        " gl_Position = vec4(yawNorm * 2.0 - 1.0, pitchNorm * 2.0 - 1.0, distance / 100.0, 1.0);\n"
    "}\n";

const char* fragmentShaderTraditional =
    "#version 450 core\n"
    "\n"
    "in vec2 TexCoord;\n"
    "in float TexIndex;\n"
    "out vec4 FragColor;\n"
    "layout(std430, binding = 0) buffer ColorBuffer {\n"
    "    float colors[];\n"
    "};\n"
    "\n"
    "uniform uint textureOffsets[3];\n"
    "uniform ivec2 textureSizes[3];\n"
    "void main() {\n"
    "    int index = int(TexIndex);\n"
    "    ivec2 texSize = textureSizes[index];\n"
    "    vec2 uv = clamp(TexCoord, 0.0, 1.0);\n"
    "    int x = int(uv.x * float(texSize.x));\n"
    "    int y = int(uv.y * float(texSize.y));\n"
    "    int pixelIndex = int(textureOffsets[index]) + (y * texSize.x + x) * 4;\n"
    "    FragColor = vec4(colors[pixelIndex], colors[pixelIndex + 1], colors[pixelIndex + 2], colors[pixelIndex + 3]);\n"
    "}\n";
