const char* fragmentShaderTraditional =
    "#version 450 core\n"
    "#extension GL_ARB_shading_language_packing : require\n"

    "in vec2 TexCoord;\n"
    "in vec2 TexCoordLightmap;\n"
    "in vec3 Normal;\n"
    "in vec3 FragPos;\n"

    "uniform int debugView;\n"
    "uniform float overrideGlowR = 0.0;\n"
    "uniform float overrideGlowG = 0.0;\n"
    "uniform float overrideGlowB = 0.0;\n"

    "flat in uint TexIndex;\n"
    "flat in uint GlowIndex;\n"
    "flat in uint SpecIndex;\n"
    "flat in uint NormalIndex;\n"
    "flat in uint InstanceIndex;\n"
    "const uint MATERIAL_IDX_MAX = 2048;\n"

    "layout(location = 0) out vec4 outAlbedo;   // GL_COLOR_ATTACHMENT0\n"
    "layout(location = 1) out vec4 outWorldPos; // GL_COLOR_ATTACHMENT1\n"
    "layout(location = 2) out vec4 outNormal;   // GL_COLOR_ATTACHMENT2\n"

    "layout(std430, binding = 12) buffer ColorBuffer { uint colors[]; }; // 1D color array (RGBA)\n"
    "layout(std430, binding = 14) buffer TextureOffsets { uint textureOffsets[]; }; // Starting index in colors for each texture\n"
    "layout(std430, binding = 15) buffer TextureSizes { ivec2 textureSizes[]; }; // x,y pairs for width and height of textures\n"
    "layout(std430, binding = 16) buffer TexturePalettes { uint texturePalettes[]; }; // Palette colors\n"
    "layout(std430, binding = 17) buffer TexturePaletteOffsets { uint texturePaletteOffsets[]; }; // Palette starting indices for each texture\n"

    "vec4 getTextureColor(uint texIndex, ivec2 texCoord) {\n"
    "    if (texIndex >= MATERIAL_IDX_MAX) return vec4(0.0,0.0,0.0,1.0);\n"

    "    uint pixelOffset = textureOffsets[texIndex] + texCoord.y * textureSizes[texIndex].x + texCoord.x;\n"
    "    uint slotIndex = pixelOffset / 2;\n"
    "    uint packedIdx = colors[slotIndex];\n"
    "    uint paletteIndex = (pixelOffset % 2 == 0) ? (packedIdx & 0xFFFF) : (packedIdx >> 16);\n"
    "    uint paletteOffset = texturePaletteOffsets[texIndex];\n"
    "    uint color = texturePalettes[paletteOffset + paletteIndex];\n"
    "    return vec4(\n"
    "        float((color >> 24) & 0xFF) / 255.0,\n"
    "        float((color >> 16) & 0xFF) / 255.0,\n"
    "        float((color >> 8) & 0xFF) / 255.0,\n"
    "        float(color & 0xFF) / 255.0\n"
    "    );\n"
    "}\n"

    "uint packColor(vec4 color) {\n"
    "    uvec4 c = uvec4(clamp(color * 255.0, 0.0, 255.0));\n"
    "    return (c.r << 24) | (c.g << 16) | (c.b << 8) | c.a;\n"
    "}\n"

    "void main() {\n"
    "    int texIndexChecked = 0;\n"
    "    if (TexIndex >= 0) texIndexChecked = int(TexIndex);\n"
    "    ivec2 texSize = textureSizes[texIndexChecked];\n"
    "    vec2 uv = clamp(vec2(TexCoord.x, 1.0 - TexCoord.y), 0.0, 1.0); // Invert V, OpenGL convention vs import\n"
    "    int x = int(floor(uv.x * float(texSize.x)));\n"
    "    int y = int(floor(uv.y * float(texSize.y)));\n"
    "    vec4 albedoColor = getTextureColor(texIndexChecked,ivec2(x,y));\n"
    "    if (albedoColor.a < 0.05) discard; // Alpha cutout threshold\n"

    "    vec3 adjustedNormal = Normal;\n"
    "    if (NormalIndex < MATERIAL_IDX_MAX && NormalIndex > 0 && NormalIndex != 41) {\n"
    "    vec3 dp1 = dFdx(FragPos);\n"
    "    vec3 dp2 = dFdy(FragPos);\n"
    "    vec2 duv1 = dFdx(TexCoord);\n"
    "    vec2 duv2 = dFdy(TexCoord);\n"
    "    float uvArea = abs(duv1.x * duv2.y - duv1.y * duv2.x);\n"
    "    if (uvArea > 1e-4) {\n"
    "        if (length(duv1) > 1e-6 && length(duv2) > 1e-6) {\n"
    "            vec3 t = normalize(dp1 * duv2.y - dp2 * duv1.y);\n"
    "            vec3 b = normalize(-dp1 * duv2.x + dp2 * duv1.x);\n"
    "            mat3 TBN3x3 = mat3(t, b, Normal);\n"
    "            vec3 normalColor = normalize(getTextureColor(NormalIndex,ivec2(x,y)).rgb * 2.0 - 1.0);\n"
    "            normalColor.g = -normalColor.g;\n"
    "            adjustedNormal = normalize(TBN3x3 * normalColor);\n"
    "        }\n"
    "    }\n"
    "    if (!gl_FrontFacing) adjustedNormal = -adjustedNormal;\n"
    "    vec4 glowColor = getTextureColor(GlowIndex,ivec2(x,y));\n"
    "    vec4 specColor = getTextureColor(SpecIndex,ivec2(x,y));\n"
    "    vec4 worldPosPack = vec4(FragPos,uintBitsToFloat(InstanceIndex));\n"
    "    vec3 worldPos = worldPosPack.xyz;\n"
    "    if (debugView == 1) {\n"
    "        outAlbedo = albedoColor;\n"
    "        outAlbedo.a = 1.0;\n"
    "    } else if (debugView == 2) {\n"
    "        outAlbedo.r = (adjustedNormal.x + 1.0) * 0.5f;\n"
    "        outAlbedo.g = (adjustedNormal.y + 1.0) * 0.5f;\n"
    "        outAlbedo.b = (adjustedNormal.z + 1.0) * 0.5f;\n"
    "        outAlbedo.a = 1.0;\n"
    "    } else if (debugView == 3) {\n"
    "        float ndcDepth = (2.0 * gl_FragCoord.z - 1.0); // Depth debug\n"
    "        float clipDepth = ndcDepth / gl_FragCoord.w;\n"
    "        float linearDepth = (clipDepth - 0.02) / (100.0 - 0.02);\n"
    "        outAlbedo = vec4(vec3(linearDepth), 1.0);\n"
    "    } else if (debugView == 4) {\n"
    "        outAlbedo.r = float(InstanceIndex) / 5500.0;\n"
    "        outAlbedo.g = 0.0;\n"
    "        outAlbedo.b = float(texIndexChecked) / 1231.0;\n"
    "        outAlbedo.a = 1.0;\n"
    "    } else if (debugView == 5) { // Worldpos debug\n"
    "        outAlbedo.rgb = worldPos;\n"
    "        outAlbedo.a = 1.0;\n"
    "    } else if (debugView == 6) { // Lightview Mode\n"
    "        outAlbedo = vec4(overrideGlowR,overrideGlowG,overrideGlowB,1.0);\n"
    "    } else {\n"
    "        outAlbedo.rgb = albedoColor.rgb * albedoColor.a;\n"
    "        outAlbedo.a = uintBitsToFloat(packHalf2x16(TexCoordLightmap.xy));\n"
    "    }\n"
    "    outNormal.r = uintBitsToFloat(packHalf2x16(adjustedNormal.xy));\n"
    "    outNormal.g = uintBitsToFloat(packHalf2x16(vec2(adjustedNormal.z,0.0)));\n"
    "    outNormal.b = uintBitsToFloat(packColor(glowColor));\n"
    "    outNormal.a = uintBitsToFloat(packColor(specColor));\n"
    "    outWorldPos = worldPosPack;\n"
    "}\n";
