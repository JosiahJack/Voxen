// deferred_lighting_debug_spot.compute
#version 450 core
layout(local_size_x = 32, local_size_y = 32) in;

layout(rgba8,   binding =  0) uniform image2D inputImage;
layout(rgba32f, binding =  1) uniform image2D inputWorldPos;
layout(std430,  binding =  5) buffer ShadowMaps { float shadowMaps[]; };
layout(std430,  binding = 13) buffer BlueNoise { float blueNoiseColors[]; };
layout(std430,  binding = 19) buffer LightIndices { float lights[]; };
layout(std430,  binding = 26) buffer VoxelLightListIndices { uint voxelLightListIndices[]; };
layout(std430,  binding = 27) buffer UniqueLightLists { uint uniqueLightLists[]; };

uniform uint totalLuxelCount;
uniform uint screenWidth;
uniform uint screenHeight;
uniform uint modelCount;
uniform mat4 viewProjection;
uniform mat4 invViewProjection;
uniform int debugView;
uniform int debugValue;
uniform float worldMin_x;
uniform float worldMin_z;
uniform vec3 camPos;
uniform float fogColorR;
uniform float fogColorG;
uniform float fogColorB;

vec4 unpackColor32(uint color) {
    return vec4(float((color >> 24) & 0xFF) / 255.0,
                float((color >> 16) & 0xFF) / 255.0,
                float((color >>  8) & 0xFF) / 255.0,
                float((color      ) & 0xFF) / 255.0);
}

vec3 quat_rotate(vec4 q, vec3 v) {
    float x2 = q.x + q.x;
    float y2 = q.y + q.y;
    float z2 = q.z + q.z;
    float xx2 = q.x * x2;
    float yy2 = q.y * y2;
    float zz2 = q.z * z2;
    float xy2 = q.x * y2;
    float xz2 = q.x * z2;
    float yz2 = q.y * z2;
    float wx2 = q.w * x2;
    float wy2 = q.w * y2;
    float wz2 = q.w * z2;
    return vec3(
        v.x * (1.0 - yy2 - zz2) + v.y * (xy2 - wz2) + v.z * (xz2 + wy2),
        v.x * (xy2 + wz2) + v.y * (1.0 - xx2 - zz2) + v.z * (yz2 - wx2),
        v.x * (xz2 - wy2) + v.y * (yz2 + wx2) + v.z * (1.0 - xx2 - yy2)
    );
}

const int LIGHT_DATA_SIZE = 13;
const int LIGHT_DATA_OFFSET_POSX = 0;
const int LIGHT_DATA_OFFSET_POSY = 1;
const int LIGHT_DATA_OFFSET_POSZ = 2;
const int LIGHT_DATA_OFFSET_INTENSITY = 3;
const int LIGHT_DATA_OFFSET_RANGE = 4;
const int LIGHT_DATA_OFFSET_SPOTANG = 5;
const int LIGHT_DATA_OFFSET_SPOTDIRX = 6;
const int LIGHT_DATA_OFFSET_SPOTDIRY = 7;
const int LIGHT_DATA_OFFSET_SPOTDIRZ = 8;
const int LIGHT_DATA_OFFSET_SPOTDIRW = 9;
const int LIGHT_DATA_OFFSET_R = 10;
const int LIGHT_DATA_OFFSET_G = 11;
const int LIGHT_DATA_OFFSET_B = 12;
const float WORLDCELL_WIDTH_F = 2.56;
const float VOXEL_SIZE = 0.32;
const vec3 baseDir = vec3(0.0, 0.0, 1.0);

uint GetVoxelIndex(vec3 worldPos) {
    float offsetX = worldPos.x - worldMin_x + (VOXEL_SIZE * 0.5);
    float offsetZ = worldPos.z - worldMin_z + (VOXEL_SIZE * 0.5);
    uint cellX = uint(offsetX / WORLDCELL_WIDTH_F);
    uint cellZ = uint(offsetZ / WORLDCELL_WIDTH_F);
    float localX = mod(offsetX, WORLDCELL_WIDTH_F);
    float localZ = mod(offsetZ, WORLDCELL_WIDTH_F);
    uint voxelX = uint(localX / VOXEL_SIZE);
    uint voxelZ = uint(localZ / VOXEL_SIZE);
    uint cellIndex = cellZ * 64 + cellX;
    uint voxelIndexInCell = voxelZ * 8 + voxelX;
    return cellIndex * 64 + voxelIndexInCell;
}

const int shadowMapSize = 128;

float SampleShadowMap(uint lightIdx, vec3 worldPos, vec3 lightPos, vec3 normal, vec3 lightDir, float lightRange, float distToPixel, ivec2 pixel) {
    vec3 toLight = worldPos - lightPos;
    float dist = length(toLight);
    float rangeFac = ((lightRange - dist) / lightRange);
    float smearness = rangeFac * 5.0;
    float slope = max(0.0, 1.0 - dot(normalize(normal), normalize(lightDir)));
    float bias = slope * ((1.0 / float(shadowMapSize)) + (0.35 * (1.0 - rangeFac)));
    vec3 a = abs(toLight);
    float maxAxis = max(max(a.x, a.y), a.z);
    vec3 dir = toLight / maxAxis;
    uint face;
    vec2 uv;
    if (a.x >= a.y && a.x >= a.z) {
        face = toLight.x > 0.0 ? 0u : 1u; uv = face == 0u ? vec2(-dir.z, dir.y) : vec2(dir.z, dir.y);
    } else if (a.y >= a.x && a.y >= a.z) {
        face = toLight.y > 0.0 ? 2u : 3u; uv = face == 2u ? vec2(dir.x, -dir.z) : vec2(dir.x, dir.z);
    } else {
        face = toLight.z > 0.0 ? 4u : 5u; uv = face == 4u ? vec2(dir.x, dir.y) : vec2(-dir.x, dir.y);
    }
    
    uv = uv * 0.5 + 0.5;
    float shadSizeF = float(shadowMapSize);
    uint base = lightIdx * 6u * uint(shadowMapSize) * uint(shadowMapSize);
    uint faceOff = base + face * uint(shadowMapSize) * uint(shadowMapSize);
    vec2 tc = uv * shadSizeF;
    float sum = 0.0;
    float totalWeight = 0.0001;
    float weight = 1.0 / 25.0;
    float radiusF = 10.24;
    // 3x3 kernel with blue noise offset and soft depth comparison
    for (float y = -smearness; y <= smearness; y += 1.0) {
        for (float x = -smearness; x <= smearness; x += 1.0) {
            vec2 t = tc + vec2(x, y);
            uint utx = uint(clamp(t.x, 0.0, shadSizeF - 1.0));
            uint uty = uint(clamp(t.y, 0.0, shadSizeF - 1.0));
            uint idx = faceOff + uty * uint(shadowMapSize) + utx;
            float d = shadowMaps[idx];
            float depthDiff = dist - d - bias; // Soft depth comparison
            float shadowContrib = clamp(1.0 - depthDiff / 0.16, 0.0, 1.0); // Softer transition
            sum += shadowContrib * weight;
            totalWeight += weight;
        }
    }

    return sum / totalWeight;
}

// Main Compute Shader
void main() {
    uvec2 pixelu = gl_GlobalInvocationID.xy;
    ivec2 pixel = ivec2(pixelu);
    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;

    vec4 worldPosPack = imageLoad(inputWorldPos, pixel);
    vec2 worldXY = unpackHalf2x16(floatBitsToUint(worldPosPack.r));
    vec2 worldZInst = unpackHalf2x16(floatBitsToUint(worldPosPack.g));
    vec3 worldPos = vec3(worldXY.x, worldXY.y, worldZInst.x);
    vec4 color = vec4(imageLoad(inputImage, pixel));
    float distToPixel = length(worldPos - camPos);
    if (distToPixel > 71.66) return;
    
    vec4 glowColor = unpackColor32(floatBitsToUint(worldPosPack.b));
    vec4 specColor = unpackColor32(floatBitsToUint(worldPosPack.a));
    uint pixelInstance = floatBitsToUint(worldZInst.y);
    uint voxelIdx = GetVoxelIndex(worldPos);
    uint count  = voxelLightListIndices[voxelIdx * 2 + 1];
    vec3 lighting = vec3(0.0, 0.0, 0.0);
    vec3 normal = vec3(0.0,0.0,1.0);
    uint listoffset = 0;
    if (count > 0) {
        normal.x = (glowColor.a * 2.0) -1.0;
        normal.y = (specColor.a * 2.0) - 1.0;
        normal.z = (glowColor.r * 2.0) - 1.0;
        normal = normalize(normal);
        listoffset = voxelLightListIndices[voxelIdx * 2];
    }

    glowColor.r = color.a;

    for (uint i = 0u; i < count; i++) {
        uint lightIdxInPVS = uniqueLightLists[listoffset + i];
        uint lightIdx = lightIdxInPVS * uint(LIGHT_DATA_SIZE);
        float intensity = lights[lightIdx + LIGHT_DATA_OFFSET_INTENSITY];
        if (intensity < 0.05) continue;

        float range = lights[lightIdx + LIGHT_DATA_OFFSET_RANGE];
        vec3 lightPos = vec3(lights[lightIdx + LIGHT_DATA_OFFSET_POSX],
                             lights[lightIdx + LIGHT_DATA_OFFSET_POSY],
                             lights[lightIdx + LIGHT_DATA_OFFSET_POSZ]);
        vec3 toLight = lightPos - worldPos;
        float dist = length(toLight);
        if (dist > range) continue;

        vec3 lightDir = normalize(toLight);
        float lambertian = max(dot(normal, lightDir), 0.0);
        if (lambertian < 0.25) continue;

        float spotAng = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTANG];
        float spotFalloff = 1.0;
        if (spotAng > 0.0) { // Extremely rare, only ~15 spot lights in entire game out of several thousand lights.
            float quat_x = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRX];
            float quat_y = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRY];
            float quat_z = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRZ];
            float quat_w = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRW];
            vec4 quat = vec4(quat_x, quat_y, quat_z, quat_w);
            vec3 spotDir = normalize(quat_rotate(quat, baseDir));
            float spotdot = dot(spotDir, -lightDir);
            float cosAngle = cos(radians(spotAng / 2.0));
            if (spotdot < cosAngle) continue;
            float cosOuterAngle = cos(radians(spotAng / 2.0));
            float cosInnerAngle = cos(radians(spotAng * 0.8 / 2.0));
            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);
            if (spotFalloff <= 0.0) continue;
        }

        float distOverRange = dist / range;
        float attenuation = (1.0 - (distOverRange * distOverRange)) * lambertian;
        float shadowFactor = SampleShadowMap(lightIdxInPVS, worldPos, lightPos, normal, lightDir, range, distToPixel, pixel);
        if (debugValue == 2) shadowFactor = 1.0;
        vec3 lightColor = vec3(lights[lightIdx + LIGHT_DATA_OFFSET_R], lights[lightIdx + LIGHT_DATA_OFFSET_G], lights[lightIdx + LIGHT_DATA_OFFSET_B]);
        lighting += color.rgb * (intensity * 0.4) * pow(attenuation, 1.6) * lightColor * spotFalloff * shadowFactor;
    }

    lighting += glowColor.rgb;

    // Dither + fog
    int blueNoiseTextureWidth = 64;
    int pixelIndex = int(((int(pixel.y) % blueNoiseTextureWidth) * blueNoiseTextureWidth + (int(pixel.x) % blueNoiseTextureWidth))) * 3;
    vec4 bluenoise = vec4(blueNoiseColors[pixelIndex], blueNoiseColors[pixelIndex + 1], blueNoiseColors[pixelIndex + 2], 1.0);
    if (debugValue == 0) lighting += ((bluenoise.rgb * 1.0/255.0) - (0.5/255.0));

    float fogFac = clamp(distToPixel / 71.68, 0.0, 1.0);
    float lum = dot(lighting, vec3(0.299, 0.587, 0.114));
    vec3 fogColor = vec3(fogColorR, fogColorG, fogColorB);
    fogFac = clamp(fogFac * (1.0 - lum), 0.0, 1.0);
    lighting = mix(fogColor, lighting, 1.0 - fogFac);

    imageStore(inputImage, pixel, vec4(lighting, 1.0));
}
