// deferred_lighting_debug_spot.compute
#version 450 core
layout(local_size_x = 32, local_size_y = 32) in;
const int LIGHT_COUNT = 1600;

layout(rgba8,   binding =  0) uniform image2D inputImage;
layout(rgba32f, binding =  1) uniform image2D inputWorldPos;
layout(std430,  binding =  5) buffer ShadowMaps { float shadowMaps[]; };
layout(std430,  binding =  6) buffer LightIndirectionIndices { uint lightIndirectionIndices[]; };
layout(std430,  binding =  8) buffer PrecomputedVisibleCellsFromHere { uint precomputedVisibleCellsFromHere[]; };
layout(std430,  binding = 13) buffer BlueNoise { float blueNoiseColors[]; };
layout(std430,  binding = 19) buffer LightIndices { float lights[]; };
layout(std430,  binding = 20) buffer CellIndexForInstance { uint cellIndexForInstance[]; };
layout(std430,  binding = 26) buffer VoxelLightListIndices { uint voxelLightListIndices[]; };
layout(std430,  binding = 27) buffer UniqueLightLists { uint uniqueLightLists[]; };

uniform uint totalLuxelCount;
uniform uint screenWidth;
uniform uint screenHeight;
uniform uint modelCount;
uniform mat4 viewProjection;
uniform mat4 invViewProjection;
uniform int debugView;
uniform int debugValue;
uniform float worldMin_x;
uniform float worldMin_z;
uniform vec3 camPos;
uniform float fogColorR;
uniform float fogColorG;
uniform float fogColorB;

vec4 unpackColor32(uint color) {
    return vec4(float((color >> 24) & 0xFF) / 255.0,
                float((color >> 16) & 0xFF) / 255.0,
                float((color >>  8) & 0xFF) / 255.0,
                float((color      ) & 0xFF) / 255.0);
}

vec3 quat_rotate(vec4 q, vec3 v) {
    float x2 = q.x + q.x;
    float y2 = q.y + q.y;
    float z2 = q.z + q.z;
    float xx2 = q.x * x2;
    float yy2 = q.y * y2;
    float zz2 = q.z * z2;
    float xy2 = q.x * y2;
    float xz2 = q.x * z2;
    float yz2 = q.y * z2;
    float wx2 = q.w * x2;
    float wy2 = q.w * y2;
    float wz2 = q.w * z2;
    return vec3(
        v.x * (1.0 - yy2 - zz2) + v.y * (xy2 - wz2) + v.z * (xz2 + wy2),
        v.x * (xy2 + wz2) + v.y * (1.0 - xx2 - zz2) + v.z * (yz2 - wx2),
        v.x * (xz2 - wy2) + v.y * (yz2 + wx2) + v.z * (1.0 - xx2 - yy2)
    );
}

const int LIGHT_DATA_SIZE = 13;
const int LIGHT_DATA_OFFSET_POSX = 0;
const int LIGHT_DATA_OFFSET_POSY = 1;
const int LIGHT_DATA_OFFSET_POSZ = 2;
const int LIGHT_DATA_OFFSET_INTENSITY = 3;
const int LIGHT_DATA_OFFSET_RANGE = 4;
const int LIGHT_DATA_OFFSET_SPOTANG = 5;
const int LIGHT_DATA_OFFSET_SPOTDIRX = 6;
const int LIGHT_DATA_OFFSET_SPOTDIRY = 7;
const int LIGHT_DATA_OFFSET_SPOTDIRZ = 8;
const int LIGHT_DATA_OFFSET_SPOTDIRW = 9;
const int LIGHT_DATA_OFFSET_R = 10;
const int LIGHT_DATA_OFFSET_G = 11;
const int LIGHT_DATA_OFFSET_B = 12;
const float WORLDCELL_WIDTH_F = 2.56;
const float VOXEL_SIZE = 0.32;
const float CELLXHALF = 1.28;
const vec3 baseDir = vec3(0.0, 0.0, 1.0);
const int SSR_RES = 4;
const float FAR_PLANE = 71.68;
const float NEAR_PLANE = 0.02;

uint GetVoxelIndex(vec3 worldPos) {
    float offsetX = worldPos.x - worldMin_x + (VOXEL_SIZE * 0.5);
    float offsetZ = worldPos.z - worldMin_z + (VOXEL_SIZE * 0.5);
    uint cellX = uint(offsetX / WORLDCELL_WIDTH_F);
    uint cellZ = uint(offsetZ / WORLDCELL_WIDTH_F);
    float localX = mod(offsetX, WORLDCELL_WIDTH_F);
    float localZ = mod(offsetZ, WORLDCELL_WIDTH_F);
    uint voxelX = uint(localX / VOXEL_SIZE);
    uint voxelZ = uint(localZ / VOXEL_SIZE);
    uint cellIndex = cellZ * 64 + cellX;
    uint voxelIndexInCell = voxelZ * 8 + voxelX;
    return cellIndex * 64 + voxelIndexInCell;
}

uvec2 PosToCellCoords(float pos_x, float pos_z) {
    uvec2 retval;
    retval.x = uint(int((pos_x - worldMin_x + CELLXHALF) / WORLDCELL_WIDTH_F));
    retval.y = uint(int((pos_z - worldMin_z + CELLXHALF) / WORLDCELL_WIDTH_F));
    return retval;
}

const int shadowMapSize = 256;
const float LIGHT_NEAR_PLANE = 0.02;
const float LIGHT_FAR_PLANE = 15.36;
const float SHADOWMAP_FOV = 90.0;

float SampleShadowMap(uint lightIdx, vec3 worldPos, vec3 lightPos) {
    vec3 toLight = worldPos - lightPos;
    float dist = length(toLight);
    vec3 absToLight = abs(toLight);
    uint face;
    vec2 uv;
    float ma = max(max(absToLight.x, absToLight.y), absToLight.z);
    vec3 dir = toLight / ma;

    if (absToLight.x >= absToLight.y && absToLight.x >= absToLight.z) {
        face = toLight.x > 0.0 ? 0u : 1u; // +X or -X
        uv = face == 0u ? vec2(-dir.z, dir.y) : vec2(dir.z, dir.y); // Flip Y for consistency
    } else if (absToLight.y >= absToLight.x && absToLight.y >= absToLight.z) {
        face = toLight.y > 0.0 ? 2u : 3u; // +Y or -Y
        uv = face == 2u ? vec2(dir.x, -dir.z) : vec2(dir.x, dir.z); // Flip Z for -Y
    } else {
        face = toLight.z > 0.0 ? 4u : 5u; // +Z or -Z
        uv = face == 4u ? vec2(dir.x, dir.y) : vec2(-dir.x, dir.y); // Flip Y for consistency
    }
    uv = uv * 0.5 + 0.5;
    uv = clamp(uv, 0.001, 0.999);

    uint baseOffset = lightIdx * 6u * uint(shadowMapSize) * uint(shadowMapSize);
    uint faceOffset = baseOffset + face * uint(shadowMapSize) * uint(shadowMapSize);
    ivec2 texel = ivec2(floor(uv * float(shadowMapSize)));
    if (texel.x < 0 || texel.y < 0 || texel.x >= shadowMapSize || texel.y >= shadowMapSize) return 1.0;

    uint offset = faceOffset + uint(texel.y) * uint(shadowMapSize) + uint(texel.x);
    float depth = shadowMaps[offset];
    float bias = -0.05;
    return (depth < dist + bias) ? 0.0 : 1.0;
}

float rad2deg(float radians) { return radians * (180.0 / 3.1415926535); }

// Main Compute Shader
void main() {
    uvec2 pixelu = gl_GlobalInvocationID.xy;
    ivec2 pixel = ivec2(pixelu);
    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;

    vec4 worldPosPack = imageLoad(inputWorldPos, pixel);
    vec2 worldXY = unpackHalf2x16(floatBitsToUint(worldPosPack.r));
    vec2 worldZInst = unpackHalf2x16(floatBitsToUint(worldPosPack.g));
    vec3 worldPos = vec3(worldXY.x, worldXY.y, worldZInst.x);
    vec4 color = vec4(imageLoad(inputImage, pixel));
    float distToPixel = length(worldPos - camPos);
    vec4 glowColor = unpackColor32(floatBitsToUint(worldPosPack.b));
    vec4 specColor = unpackColor32(floatBitsToUint(worldPosPack.a));
    uint pixelInstance = floatBitsToUint(worldZInst.y);
    uint voxelIdx = GetVoxelIndex(worldPos);
    uint count  = voxelLightListIndices[voxelIdx * 2 + 1];
    vec3 lighting = vec3(0.0, 0.0, 0.0);
    vec3 normal = vec3(0.0,0.0,1.0);
    uint listoffset = 0;
    if (count > 0) {
        normal.x = (glowColor.a * 2.0) -1.0;
        normal.y = (specColor.a * 2.0) - 1.0;
        normal.z = (glowColor.r * 2.0) - 1.0;
        normal = normalize(normal);
        listoffset = voxelLightListIndices[voxelIdx * 2];
    }

    glowColor.r = color.a;

    for (uint i = 0u; i < count; i++) {
        uint lightIdxInPVS = uniqueLightLists[listoffset + i];
        uint lightIdx = lightIdxInPVS * uint(LIGHT_DATA_SIZE);
        float intensity = lights[lightIdx + LIGHT_DATA_OFFSET_INTENSITY];
        if (intensity < 0.05) continue;

        float range = lights[lightIdx + LIGHT_DATA_OFFSET_RANGE];
        vec3 lightPos = vec3(lights[lightIdx + LIGHT_DATA_OFFSET_POSX],
                             lights[lightIdx + LIGHT_DATA_OFFSET_POSY],
                             lights[lightIdx + LIGHT_DATA_OFFSET_POSZ]);
        vec3 toLight = lightPos - worldPos;
        float dist = length(toLight);
//         if (dist > range) continue;

        vec3 lightDir = normalize(toLight);
        float lambertian = max(dot(normal, lightDir), 0.0);
//         if (lambertian < 0.25) continue;

//         if (dist > 7.68) {
//             uvec2 lightCell = PosToCellCoords(lightPos.x, lightPos.z);
//             uint checkCellIdx = cellIndexForInstance[pixelInstance];
//             uint lightCellIdx1D = (lightCell.y * 64u) + lightCell.x;
//             uint bitIndex = lightCellIdx1D * 4096u + checkCellIdx;
//             uint wordIdx = bitIndex / 32u;
//             uint bitPos = bitIndex % 32u;
//             bool lightCanSeeCell = (precomputedVisibleCellsFromHere[wordIdx] & (1u << bitPos)) != 0u;
//             if (!lightCanSeeCell) continue;
//         }

        float spotAng = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTANG];
        float spotFalloff = 1.0;
        if (spotAng > 0.0) {
            float quat_x = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRX];
            float quat_y = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRY];
            float quat_z = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRZ];
            float quat_w = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRW];
            vec4 quat = vec4(quat_x, quat_y, quat_z, quat_w);
            vec3 spotDir = normalize(quat_rotate(quat, baseDir));
            float spotdot = dot(spotDir, -lightDir);
            float cosAngle = cos(radians(spotAng / 2.0));
            if (spotdot < cosAngle) continue;
            float cosOuterAngle = cos(radians(spotAng / 2.0));
            float cosInnerAngle = cos(radians(spotAng * 0.8 / 2.0));
            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);
            if (spotFalloff <= 0.0) continue;
        }

        vec3 lightColor = vec3(lights[lightIdx + LIGHT_DATA_OFFSET_R],
                               lights[lightIdx + LIGHT_DATA_OFFSET_G],
                               lights[lightIdx + LIGHT_DATA_OFFSET_B]);
        float distOverRange = dist / range;
        float attenuation = (1.0 - (distOverRange * distOverRange)) * lambertian;
        float shadowFactor = SampleShadowMap(lightIdxInPVS, worldPos, lightPos);
        if (shadowFactor > 0.4 && shadowFactor < 0.6) return;
        if (lightIdxInPVS != 817u) shadowFactor = 0.0; // placeholder while debugging with single test light near player start for now
        lighting += color.rgb * (intensity * 0.4) * pow(attenuation, 1.6) * lightColor * spotFalloff * shadowFactor;
    }

    lighting += glowColor.rgb;

    // Dither + fog
    int blueNoiseTextureWidth = 64;
    int pixelIndex = int(((int(pixel.y) % blueNoiseTextureWidth) * blueNoiseTextureWidth + (int(pixel.x) % blueNoiseTextureWidth))) * 3;
    vec4 bluenoise = vec4(blueNoiseColors[pixelIndex], blueNoiseColors[pixelIndex + 1], blueNoiseColors[pixelIndex + 2], 1.0);
    if (debugValue == 0) lighting += ((bluenoise.rgb * 1.0/255.0) - (0.5/255.0));

    float fogFac = clamp(distToPixel / 71.68, 0.0, 1.0);
    float lum = dot(lighting, vec3(0.299, 0.587, 0.114));
    vec3 fogColor = vec3(fogColorR, fogColorG, fogColorB);
    fogFac = clamp(fogFac * (1.0 - lum), 0.0, 1.0);
    lighting = mix(fogColor, lighting, 1.0 - fogFac);

    imageStore(inputImage, pixel, vec4(lighting, 1.0));
}
