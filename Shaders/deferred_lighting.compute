// deferred_lighting.compute
// Compute shader for processing 
#version 450 core
layout(local_size_x = 32, local_size_y = 32) in;
const int LIGHT_COUNT = 1600;

layout(rgba8,   binding =  0) uniform image2D inputImage;
layout(rgba32f, binding =  1) uniform image2D inputWorldPos;
// layout(         binding =  3) uniform sampler2D depthTexture; // Unused but slot taken
layout(std430,  binding =  5) buffer ShadowMaps { float shadowMaps[]; };
layout(std430,  binding =  6) buffer LightIndirectionIndices { uint lightIndirectionIndices[]; };
layout(std430,  binding =  8) buffer PrecomputedVisibleCellsFromHere { uint precomputedVisibleCellsFromHere[]; };
layout(std430,  binding = 13) buffer BlueNoise { float blueNoiseColors[]; };
layout(std430,  binding = 19) buffer LightIndices { float lights[]; };
layout(std430,  binding = 20) buffer CellIndexForInstance { uint cellIndexForInstance[]; };
layout(std430,  binding = 26) buffer VoxelLightListIndices { uint voxelLightListIndices[]; };
layout(std430,  binding = 27) buffer UniqueLightLists { uint uniqueLightLists[]; };

uniform uint totalLuxelCount;
uniform uint screenWidth;
uniform uint screenHeight;
uniform uint modelCount;
uniform mat4 viewProjection;
uniform mat4 invViewProjection;
uniform int debugView;
uniform int debugValue;
uniform float worldMin_x;
uniform float worldMin_z;
uniform vec3 camPos;
uniform float fogColorR;
uniform float fogColorG;
uniform float fogColorB;

vec4 unpackColor32(uint color) {
    return vec4(float((color >> 24) & 0xFF) / 255.0,
                float((color >> 16) & 0xFF) / 255.0,
                float((color >>  8) & 0xFF) / 255.0,
                float((color      ) & 0xFF) / 255.0);
}

vec3 quat_rotate(vec4 q, vec3 v) {
    float x2 = q.x + q.x;
    float y2 = q.y + q.y;
    float z2 = q.z + q.z;
    float xx2 = q.x * x2;
    float yy2 = q.y * y2;
    float zz2 = q.z * z2;
    float xy2 = q.x * y2;
    float xz2 = q.x * z2;
    float yz2 = q.y * z2;
    float wx2 = q.w * x2;
    float wy2 = q.w * y2;
    float wz2 = q.w * z2;
    return vec3(
        v.x * (1.0 - yy2 - zz2) + v.y * (xy2 - wz2) + v.z * (xz2 + wy2),
        v.x * (xy2 + wz2) + v.y * (1.0 - xx2 - zz2) + v.z * (yz2 - wx2),
        v.x * (xz2 - wy2) + v.y * (yz2 + wx2) + v.z * (1.0 - xx2 - yy2)
    );
}

const int LIGHT_DATA_SIZE = 13;
const int LIGHT_DATA_OFFSET_POSX = 0;
const int LIGHT_DATA_OFFSET_POSY = 1;
const int LIGHT_DATA_OFFSET_POSZ = 2;
const int LIGHT_DATA_OFFSET_INTENSITY = 3;
const int LIGHT_DATA_OFFSET_RANGE = 4;
const int LIGHT_DATA_OFFSET_SPOTANG = 5;
const int LIGHT_DATA_OFFSET_SPOTDIRX = 6;
const int LIGHT_DATA_OFFSET_SPOTDIRY = 7;
const int LIGHT_DATA_OFFSET_SPOTDIRZ = 8;
const int LIGHT_DATA_OFFSET_SPOTDIRW = 9;
const int LIGHT_DATA_OFFSET_R = 10;
const int LIGHT_DATA_OFFSET_G = 11;
const int LIGHT_DATA_OFFSET_B = 12;
const float WORLDCELL_WIDTH_F = 2.56;
const float VOXEL_SIZE = 0.32;
const float CELLXHALF = 1.28;
const vec3 baseDir = vec3(0.0, 0.0, 1.0);
const int SSR_RES = 4;
const float FAR_PLANE = 71.68;
const float NEAR_PLANE = 0.02;
    
float rad2deg(float radians) { return radians * (180.0 / 3.1415926535); }

uint GetVoxelIndex(vec3 worldPos) {
    float offsetX = worldPos.x - worldMin_x + (VOXEL_SIZE * 0.5);
    float offsetZ = worldPos.z - worldMin_z + (VOXEL_SIZE * 0.5);
    uint cellX = uint(offsetX / WORLDCELL_WIDTH_F);
    uint cellZ = uint(offsetZ / WORLDCELL_WIDTH_F);
    float localX = mod(offsetX, WORLDCELL_WIDTH_F);
    float localZ = mod(offsetZ, WORLDCELL_WIDTH_F);
    uint voxelX = uint(localX / VOXEL_SIZE);
    uint voxelZ = uint(localZ / VOXEL_SIZE);
    uint cellIndex = cellZ * 64 + cellX;
    uint voxelIndexInCell = voxelZ * 8 + voxelX;
    return cellIndex * 64 + voxelIndexInCell;
}

uvec2 PosToCellCoords(float pos_x, float pos_z) {
    uvec2 retval;
    retval.x = uint(int((pos_x - worldMin_x + CELLXHALF) / WORLDCELL_WIDTH_F));
    retval.y = uint(int((pos_z - worldMin_z + CELLXHALF) / WORLDCELL_WIDTH_F));
    return retval;
}

const int shadowMapSize = 512;
const float LIGHT_RANGE_MAX = 15.36;

float SampleShadowMap(uint lightIdx, vec3 shadowCoord, uint face, float dist) {
    uint baseOffset = lightIdx * 6 * shadowMapSize * shadowMapSize;
    uint faceOffset = baseOffset + face * shadowMapSize * shadowMapSize;
    vec3 dir = normalize(shadowCoord);
    vec3 absCoord = abs(dir);
    float maxAxis = max(max(absCoord.x, absCoord.y), absCoord.z);
    vec2 uv;
    if (face == 0) { // +X
        uv = vec2(-shadowCoord.z, -shadowCoord.y) / maxAxis * 0.5 + 0.5;
    } else if (face == 1) { // -X
        uv = vec2(shadowCoord.z, -shadowCoord.y) / maxAxis * 0.5 + 0.5;
    } else if (face == 2) { // +Y
        uv = vec2(shadowCoord.x, shadowCoord.z) / maxAxis * 0.5 + 0.5;
    } else if (face == 3) { // -Y
        
        uv = vec2(shadowCoord.x, -shadowCoord.z) / maxAxis * 0.5 + 0.5;
        
    } else if (face == 4) { // +Z
        uv = vec2(shadowCoord.x, -shadowCoord.y) / maxAxis * 0.5 + 0.5;
    } else { // -Z
        uv = vec2(-shadowCoord.x, -shadowCoord.y) / maxAxis * 0.5 + 0.5;
    }

//     ivec2 texel = ivec2(uv * float(shadowMapSize));
    ivec2 texel = ivec2(floor(uv * float(shadowMapSize)));
//     texel.x = clamp(texel.x, 0, shadowMapSize-1);
//     texel.y = clamp(texel.y, 0, shadowMapSize-1);
//     texel.y = (shadowMapSize - 1) - texel.y; // flip Y
    if (texel.x >= shadowMapSize - 1 || texel.y >= shadowMapSize - 1 || texel.x < 0 || texel.y < 0) return 1.0;

    uint offset = faceOffset + texel.y * shadowMapSize + texel.x;
    float depth = shadowMaps[offset];
    float closestDepth = 2.0 * depth - 1.0; // NDC to [-1,1]
    closestDepth = (2.0 * NEAR_PLANE * 15.36) / (15.36 + NEAR_PLANE - closestDepth * (15.36 - NEAR_PLANE)); // Linearize

    float bias = -0.020;
    return (dist > closestDepth + bias) ? 0.0 : 1.0; // Use maxAxis for depth comparison
}

// Main Compute Shader
void main() {
    uvec2 pixelu = gl_GlobalInvocationID.xy;
    ivec2 pixel = ivec2(pixelu);
    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;

    vec4 worldPosPack = imageLoad(inputWorldPos, pixel);
    vec2 worldXY = unpackHalf2x16(floatBitsToUint(worldPosPack.r));
    vec2 worldZInst = unpackHalf2x16(floatBitsToUint(worldPosPack.g));
    vec3 worldPos = vec3(worldXY.x, worldXY.y, worldZInst.x);
    vec4 color = vec4(imageLoad(inputImage, pixel));
    float distToPixel = length(worldPos - camPos);
    vec4 glowColor = unpackColor32(floatBitsToUint(worldPosPack.b));
    vec4 specColor = unpackColor32(floatBitsToUint(worldPosPack.a));
    uint pixelInstance = floatBitsToUint(worldZInst.y);

    // Regular lighting calculation
    uint voxelIdx = GetVoxelIndex(worldPos);
    uint count  = voxelLightListIndices[voxelIdx * 2 + 1];    
    vec3 lighting = vec3(0.0, 0.0, 0.0);
    vec3 normal = vec3(0.0,0.0,1.0);
    uint listoffset = 0;
    if (count > 0) {  
        normal.x = (glowColor.a * 2.0) -1.0;
        normal.y = (specColor.a * 2.0) - 1.0;
        normal.z = (glowColor.r * 2.0) - 1.0; // Get the normal.z back at good precision
        normal = normalize(normal);
        listoffset = voxelLightListIndices[voxelIdx * 2];
    }
    
    glowColor.r = color.a; // Glow color doesn't suffer from precision issues like normal did.
    
    for (uint i = 0; i < count; i++) {
        uint lightIdxInPVS = uniqueLightLists[listoffset + i];
        uint lightIdx = lightIdxInPVS * LIGHT_DATA_SIZE;
        float intensity = lights[lightIdx + LIGHT_DATA_OFFSET_INTENSITY];
        if (intensity < 0.05) continue;

        float range = lights[lightIdx + LIGHT_DATA_OFFSET_RANGE];
        vec3 lightPos = vec3(lights[lightIdx + LIGHT_DATA_OFFSET_POSX],
                             lights[lightIdx + LIGHT_DATA_OFFSET_POSY],
                             lights[lightIdx + LIGHT_DATA_OFFSET_POSZ]);
        vec3 toLight = lightPos - worldPos;
        float dist = length(toLight);
        if (dist > range) continue;

        vec3 lightDir = normalize(toLight);
        float lambertian = max(dot(normal, lightDir), 0.0);
        if (lambertian < 0.25) continue;

        if (dist > 7.68) {
            uvec2 lightCell = PosToCellCoords(lightPos.x, lightPos.z);
            uint checkCellIdx = cellIndexForInstance[pixelInstance];
            uint lightCellIdx1D = (lightCell.y * 64) + lightCell.x;
            uint bitIndex = lightCellIdx1D * 4096 + checkCellIdx;
            uint wordIdx = bitIndex / 32;
            uint bitPos = bitIndex % 32;
            bool lightCanSeeCell = (precomputedVisibleCellsFromHere[wordIdx] & (1u << bitPos)) != 0u;
            if (!lightCanSeeCell) continue;
        }

        float spotAng = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTANG];
        float spotFalloff = 1.0;
        if (spotAng > 0.0) {
            float quat_x = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRX];
            float quat_y = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRY];
            float quat_z = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRZ];
            float quat_w = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRW];
            vec4 quat = vec4(quat_x, quat_y, quat_z, quat_w);
            vec3 spotDir = normalize(quat_rotate(quat, baseDir));
            float spotdot = dot(spotDir, -lightDir);
            float cosAngle = cos(radians(spotAng / 2.0));
            if (spotdot < cosAngle) continue;
            float cosOuterAngle = cos(radians(spotAng / 2.0));
            float cosInnerAngle = cos(radians(spotAng * 0.8 / 2.0));
            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);
            if (spotFalloff <= 0.0) continue;
        }

        vec3 lightColor = vec3(lights[lightIdx + LIGHT_DATA_OFFSET_R],
                               lights[lightIdx + LIGHT_DATA_OFFSET_G],
                               lights[lightIdx + LIGHT_DATA_OFFSET_B]);
        float distOverRange = dist / range;
        float attenuation = (1.0 - (distOverRange * distOverRange)) * lambertian;

        // Shadows
        vec3 absToLight = abs(toLight);
        float maxAxis = max(max(absToLight.x, absToLight.y), absToLight.z);
        uint face;
        if (absToLight.x >= absToLight.y && absToLight.x >= absToLight.z) {
            face = toLight.x > 0.0 ? 0 : 1; // +X or -X
        } else if (absToLight.y >= absToLight.x && absToLight.y >= absToLight.z) {
            face = toLight.y > 0.0 ? 2 : 3; // +Y or -Y
        } else {
            face = toLight.z > 0.0 ? 4 : 5; // +Z or -Z
        }
        float shadowFactor = lightIdxInPVS == 817 ? SampleShadowMap(lightIdxInPVS, toLight, face, dist) : 1.0;
        if (debugValue == 1) lighting += vec3(shadowFactor, shadowFactor, shadowFactor);
        else if (debugValue == 2) lighting += color.rgb * (intensity * 0.4) * pow(attenuation, 1.6) * lightColor * spotFalloff;
        else lighting += color.rgb * (intensity * 0.4) * pow(attenuation, 1.6) * lightColor * spotFalloff * shadowFactor;
    }

    lighting += glowColor.rgb;

    // Dither
    int blueNoiseTextureWidth = 64;
    int pixelIndex = int(((int(pixel.y) % blueNoiseTextureWidth) * blueNoiseTextureWidth + (int(pixel.x) % blueNoiseTextureWidth))) * 3;
    vec4 bluenoise = vec4(blueNoiseColors[pixelIndex], blueNoiseColors[pixelIndex + 1], blueNoiseColors[pixelIndex + 2], 1.0);
    if (debugValue == 0) lighting += ((bluenoise.rgb * 1.0/255.0) - (0.5/255.0));

    // Fog
    float fogFac = clamp(distToPixel / 71.68, 0.0, 1.0);
    float lum = dot(lighting, vec3(0.299, 0.587, 0.114));
    vec3 fogColor = vec3(fogColorR, fogColorG, fogColorB);
    fogFac = clamp(fogFac * (1.0 - lum), 0.0, 1.0);
    lighting = mix(fogColor, lighting, 1.0 - fogFac);
    imageStore(inputImage, pixel, vec4(lighting, 1.0));
}
