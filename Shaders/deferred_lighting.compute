// deferred_lighting.compute
// Compute shader for processing 
#version 450 core
layout(local_size_x = 32, local_size_y = 32) in;

layout(rgba8,   binding = 0) uniform image2D inputImage;
layout(rgba32f, binding = 1) uniform image2D inputWorldPos;
layout(rgba32f, binding = 2) uniform image2D inputNormals;
layout(rgba8ui, binding = 5) uniform uimage2D shadowOcclusion;
layout(std430, binding = 8) buffer PrecomputedVisibleCellsFromHere { uint precomputedVisibleCellsFromHere[]; };
layout(std430, binding = 13) buffer BlueNoise { float blueNoiseColors[]; };
layout(std430, binding = 19) buffer LightIndices { float lights[]; };
layout(std430, binding = 20) buffer CellIndexForInstance { uint cellIndexForInstance[]; };
layout(std430, binding = 26) buffer VoxelLightListIndices { uint voxelLightListIndices[]; };
layout(std430, binding = 27) buffer UniqueLightLists { uint uniqueLightLists[]; };
layout(std430, binding = 28) buffer LightShadowAngleDistsList { float lightShadowAngleDistsList[]; };
    
uniform uint totalLuxelCount;
uniform uint screenWidth;
uniform uint screenHeight;
uniform uint modelCount;
uniform mat4 viewProjection;
uniform int debugView;
uniform int debugValue;
uniform float worldMin_x;
uniform float worldMin_z;
uniform vec3 camPos;
uniform float fogColorR;
uniform float fogColorG;
uniform float fogColorB;

vec4 unpackColor32(uint color) {
    return vec4(float((color >> 24) & 0xFF) / 255.0,
                float((color >> 16) & 0xFF) / 255.0,
                float((color >>  8) & 0xFF) / 255.0,
                float((color      ) & 0xFF) / 255.0);
}

vec3 quat_rotate(vec4 q, vec3 v) {
    float x2 = q.x + q.x;
    float y2 = q.y + q.y;
    float z2 = q.z + q.z;
    float xx2 = q.x * x2;
    float yy2 = q.y * y2;
    float zz2 = q.z * z2;
    float xy2 = q.x * y2;
    float xz2 = q.x * z2;
    float yz2 = q.y * z2;
    float wx2 = q.w * x2;
    float wy2 = q.w * y2;
    float wz2 = q.w * z2;
    return vec3(
        v.x * (1.0 - yy2 - zz2) + v.y * (xy2 - wz2) + v.z * (xz2 + wy2),
        v.x * (xy2 + wz2) + v.y * (1.0 - xx2 - zz2) + v.z * (yz2 - wx2),
        v.x * (xz2 - wy2) + v.y * (yz2 + wx2) + v.z * (1.0 - xx2 - yy2)
    );
}

const int LIGHT_DATA_SIZE = 13;
const int LIGHT_DATA_OFFSET_POSX = 0;
const int LIGHT_DATA_OFFSET_POSY = 1;
const int LIGHT_DATA_OFFSET_POSZ = 2;
const int LIGHT_DATA_OFFSET_INTENSITY = 3;
const int LIGHT_DATA_OFFSET_RANGE = 4;
const int LIGHT_DATA_OFFSET_SPOTANG = 5;
const int LIGHT_DATA_OFFSET_SPOTDIRX = 6;
const int LIGHT_DATA_OFFSET_SPOTDIRY = 7;
const int LIGHT_DATA_OFFSET_SPOTDIRZ = 8;
const int LIGHT_DATA_OFFSET_SPOTDIRW = 9;
const int LIGHT_DATA_OFFSET_R = 10;
const int LIGHT_DATA_OFFSET_G = 11;
const int LIGHT_DATA_OFFSET_B = 12;
const float WORLDCELL_WIDTH_F = 2.56;
const int SHADOW_ANGLE_DEG_BINS = 360;
const float VOXEL_SIZE = 0.32;
const float CELLXHALF = 1.28;
const vec3 baseDir = vec3(0.0, 0.0, 1.0);
const int SSR_RES = 4;
    
float rad2deg(float radians) { return radians * (180.0 / 3.1415926535); }

uint GetVoxelIndex(vec3 worldPos) {
    float offsetX = worldPos.x - worldMin_x + (VOXEL_SIZE * 0.5);
    float offsetZ = worldPos.z - worldMin_z + (VOXEL_SIZE * 0.5);
    uint cellX = uint(offsetX / WORLDCELL_WIDTH_F);
    uint cellZ = uint(offsetZ / WORLDCELL_WIDTH_F);
    float localX = mod(offsetX, WORLDCELL_WIDTH_F);
    float localZ = mod(offsetZ, WORLDCELL_WIDTH_F);
    uint voxelX = uint(localX / VOXEL_SIZE);
    uint voxelZ = uint(localZ / VOXEL_SIZE);
    uint cellIndex = cellZ * 64 + cellX;
    uint voxelIndexInCell = voxelZ * 8 + voxelX;
    return cellIndex * 64 + voxelIndexInCell;
}

uvec2 PosToCellCoords(float pos_x, float pos_z) {
    uvec2 retval;
    retval.x = uint(int((pos_x - worldMin_x + CELLXHALF) / WORLDCELL_WIDTH_F));
    retval.y = uint(int((pos_z - worldMin_z + CELLXHALF) / WORLDCELL_WIDTH_F));
    return retval;
}

    // Main Compute Shader
void main() {
    uvec2 pixel = gl_GlobalInvocationID.xy;
    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;

    vec4 worldPosPack = imageLoad(inputWorldPos, ivec2(pixel));
    vec3 worldPos = worldPosPack.xyz;
    vec4 color = vec4(imageLoad(inputImage, ivec2(pixel)));
    float distToPixel = length(worldPos - camPos);
    vec4 normalPack = imageLoad(inputNormals, ivec2(pixel));
    vec4 glowColor = unpackColor32(floatBitsToUint(normalPack.b));
    int pixelInstance = floatBitsToInt(worldPosPack.a);

    // Regular lighting calculation
    uint voxelIdx = GetVoxelIndex(worldPos);
    uint count  = voxelLightListIndices[voxelIdx * 2 + 1];    
    vec3 lighting = vec3(0.0, 0.0, 0.0);
    vec3 normal = vec3(0.0,0.0,0.0);
    uint listoffset = 0;
    if (count > 0) {
        vec2 normalXY = unpackHalf2x16(floatBitsToInt(normalPack.r));
        vec2 normalZ0 = unpackHalf2x16(floatBitsToInt(normalPack.g));
        normal = vec3(normalXY.x, normalXY.y, normalZ0.x);       
        listoffset = voxelLightListIndices[voxelIdx * 2];
    }
    
    for (uint i = 0; i < count; i++) {
        uint lightIdxInPVS = uniqueLightLists[listoffset + i];
        uint lightIdx = lightIdxInPVS * LIGHT_DATA_SIZE;
        float intensity = lights[lightIdx + LIGHT_DATA_OFFSET_INTENSITY];
        if (intensity < 0.05) continue;

        float range = lights[lightIdx + LIGHT_DATA_OFFSET_RANGE];
        vec3 lightPos = vec3(lights[lightIdx + LIGHT_DATA_OFFSET_POSX],
                             lights[lightIdx + LIGHT_DATA_OFFSET_POSY],
                             lights[lightIdx + LIGHT_DATA_OFFSET_POSZ]);
        vec3 toLight = lightPos - worldPos;
        float dist = length(toLight);
        if (dist > range) continue;

        vec3 lightDir = normalize(toLight);
        float lambertian = max(dot(normal, lightDir), 0.0);
        if (lambertian < 0.25) continue;

        if (dist > 2.56) {
            uvec2 lightCell = PosToCellCoords(lightPos.x, lightPos.z);
            uint checkCellIdx = cellIndexForInstance[pixelInstance];
            uint lightCellIdx1D = (lightCell.y * 64) + lightCell.x;
            uint bitIndex = lightCellIdx1D * 4096 + checkCellIdx;
            uint wordIdx = bitIndex / 32;
            uint bitPos = bitIndex % 32;
            bool lightCanSeeCell = (precomputedVisibleCellsFromHere[wordIdx] & (1u << bitPos)) != 0u;
            if (!lightCanSeeCell) continue;
        }

        float spotAng = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTANG];
        float spotFalloff = 1.0;
        if (spotAng > 0.0) {
            float quat_x = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRX];
            float quat_y = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRY];
            float quat_z = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRZ];
            float quat_w = lights[lightIdx + LIGHT_DATA_OFFSET_SPOTDIRW];
            vec4 quat = vec4(quat_x, quat_y, quat_z, quat_w);
            vec3 spotDir = normalize(quat_rotate(quat, baseDir));
            float spotdot = dot(spotDir, -lightDir);
            float cosAngle = cos(radians(spotAng / 2.0));
            if (spotdot < cosAngle) continue;
            float cosOuterAngle = cos(radians(spotAng / 2.0));
            float cosInnerAngle = cos(radians(spotAng * 0.8 / 2.0));
            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);
            if (spotFalloff <= 0.0) continue;
        }

        vec3 lightColor = vec3(lights[lightIdx + LIGHT_DATA_OFFSET_R],
                               lights[lightIdx + LIGHT_DATA_OFFSET_G],
                               lights[lightIdx + LIGHT_DATA_OFFSET_B]);
        float distOverRange = dist / range;
        float attenuation = (1.0 - (distOverRange * distOverRange)) * lambertian;

             // Shadow
        float distsq = dot(toLight.xz, toLight.xz);
        float angleToLight = atan(toLight.z, toLight.x); // pixel -> light direction in xz plane
        if (angleToLight < 0.0) angleToLight += 2.0 * 3.14159265;
        uint slot0 = uint(rad2deg(angleToLight)) % SHADOW_ANGLE_DEG_BINS;
        uint slot1 = (slot0 + 1) % SHADOW_ANGLE_DEG_BINS;
        uint slot_1 = (slot0 + SHADOW_ANGLE_DEG_BINS - 1) % SHADOW_ANGLE_DEG_BINS;
        float distSlot_1 = lightShadowAngleDistsList[lightIdxInPVS * SHADOW_ANGLE_DEG_BINS + slot_1];
        float distSlot0 = lightShadowAngleDistsList[lightIdxInPVS * SHADOW_ANGLE_DEG_BINS + slot0];
        float distSlot1 = lightShadowAngleDistsList[lightIdxInPVS * SHADOW_ANGLE_DEG_BINS + slot1];
        float shadowFactor0 = distSlot0 < distsq ? 0.0 : 1.0;
        float shadowFactor_1 = distSlot_1 < distsq ? 0.0 : 1.0;
        float shadowFactor1 = distSlot1 < distsq ? 0.0 : 1.0;
        float t = fract(rad2deg(angleToLight)); /// fractional part for linear interpolation
        float shadowFactor = 1.0; //mix(mix(shadowFactor_1, shadowFactor0, 1.0 - t), mix(shadowFactor0, shadowFactor1, t), 0.5);

        if (debugValue == 1) lighting += vec3(shadowFactor, shadowFactor, shadowFactor);
        else if (debugValue == 2) lighting += color.rgb * (intensity * 0.4) * pow(attenuation, 1.6) * lightColor * spotFalloff;
        /*else*/ lighting += color.rgb * (intensity * 0.4) * pow(attenuation, 1.6) * lightColor * spotFalloff * shadowFactor;
    }

    lighting += glowColor.rgb;

    // Dither
    int blueNoiseTextureWidth = 64;
    int pixelIndex = int(((int(pixel.y) % blueNoiseTextureWidth) * blueNoiseTextureWidth + (int(pixel.x) % blueNoiseTextureWidth))) * 3;
    vec4 bluenoise = vec4(blueNoiseColors[pixelIndex], blueNoiseColors[pixelIndex + 1], blueNoiseColors[pixelIndex + 2], 1.0);
    if (debugValue == 0) lighting += ((bluenoise.rgb * 1.0/255.0) - (0.5/255.0));

    // Fog
    float fogFac = clamp(distToPixel / 71.68, 0.0, 1.0);
    float lum = dot(lighting, vec3(0.299, 0.587, 0.114));
    vec3 fogColor = vec3(fogColorR, fogColorG, fogColorB);
    fogFac = clamp(fogFac * (1.0 - lum), 0.0, 1.0);
    lighting = mix(fogColor, lighting, 1.0 - fogFac);
    imageStore(inputImage, ivec2(pixel), vec4(lighting, color.a));
}
