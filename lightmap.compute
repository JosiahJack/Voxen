const char* lightmap_compute_shader = 
    "#version 450 core\n"
    "layout(local_size_x = 32, local_size_y = 32) in;\n"
    "struct Instance {\n"
    "    int modelIndex;\n"
    "    int texIndex;\n"
    "    int glowIndex;\n"
    "    int specIndex;\n"
    "    int normIndex;\n"
    "    int lodIndex;\n"
    "    float posx;\n"
    "    float posy;\n"
    "    float posz;\n"
    "    float sclx;\n"
    "    float scly;\n"
    "    float sclz;\n"
    "    float rotx;\n"
    "    float roty;\n"
    "    float rotz;\n"
    "    float rotw;\n"
    "    float floorHeight;\n"
    "};\n"

    // SSBOs
    "layout(std430, binding = 7) buffer BoundsBuffer { float bounds[]; };\n"
    "layout(std430, binding = 9) readonly buffer InstancesInPVS { uint instancesIndices[]; };\n"
    "layout(std430, binding = 10) readonly buffer InstancesBuffer { Instance instances[]; };\n"
    "layout(std430, binding = 11) readonly buffer InstancesMatricesBuffer { mat4 instanceMatrices[]; };\n"
    "layout(std430, binding = 19) buffer LightIndices { float lightInPVS[]; };\n"
    "layout(std430, binding = 21) buffer LightmapLuxelData { float luxelData[]; };\n"
    "layout(std430, binding = 22) buffer LightmapOffsets { float lightmapLuxelOffsets[]; };\n"
    "layout(std430, binding = 23) buffer TriLuxel { float triLuxelMetaData[]; };\n"
    "layout(std430, binding = 26) readonly buffer VertexData { float vertices[]; };\n"
    "layout(std430, binding = 27) readonly buffer TriangleData { uint triangles[]; };\n"
    "layout(std430, binding = 28) readonly buffer VertexCounts { uint vertexCounts[]; };\n"
    "layout(std430, binding = 29) readonly buffer TriangleCounts { uint triangleCounts[]; };\n"

    // Uniforms
    "uniform uint totalLuxelCount;\n"
    "uniform uint instanceCount;\n"
    "const int MAX_VISIBLE_LIGHTS = 90;\n"
    "const int LIGHT_DATA_SIZE = 13;\n"
    "const int LIGHT_DATA_OFFSET_POSX = 0;\n"
    "const int LIGHT_DATA_OFFSET_POSY = 1;\n"
    "const int LIGHT_DATA_OFFSET_POSZ = 2;\n"
    "const int LIGHT_DATA_OFFSET_INTENSITY = 3;\n"
    "const int LIGHT_DATA_OFFSET_RANGE = 4;\n"
    "const int LIGHT_DATA_OFFSET_R = 10;\n"
    "const int LIGHT_DATA_OFFSET_G = 11;\n"
    "const int LIGHT_DATA_OFFSET_B = 12;\n"
    "const int VERTEX_ATTRIBUTES_COUNT = 16;\n"
    "const int BOUNDS_ATTRIBUTES_COUNT = 7;\n"
    "const int BOUNDS_DATA_OFFSET_MINX = 0;\n"
    "const int BOUNDS_DATA_OFFSET_MINY = 1;\n"
    "const int BOUNDS_DATA_OFFSET_MINZ = 2;\n"
    "const int BOUNDS_DATA_OFFSET_MAXX = 3;\n"
    "const int BOUNDS_DATA_OFFSET_MAXY = 4;\n"
    "const int BOUNDS_DATA_OFFSET_MAXZ = 5;\n"

    // Ray-Triangle Intersection (MÃ¶ller-Trumbore)
    "bool RayTriangle(vec3 origin, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out float t) {\n"
    "    vec3 edge1 = v1 - v0;\n"
    "    vec3 edge2 = v2 - v0;\n"
    "    vec3 h = cross(dir, edge2);\n"
    "    float a = dot(edge1, h);\n"
    "    if (abs(a) < 1e-6) return false;\n"
    "    float f = 1.0 / a;\n"
    "    vec3 s = origin - v0;\n"
    "    float u = f * dot(s, h);\n"
    "    if (u < 0.0 || u > 1.0) return false;\n"
    "    vec3 q = cross(s, edge1);\n"
    "    float v = f * dot(dir, q);\n"
    "    if (v < 0.0 || u + v > 1.0) return false;\n"
    "    t = f * dot(edge2, q);\n"
    "    return t > 0.001;\n"
    "}\n"

    // Compute barycentric coordinates in 2D UV space
    "vec3 Barycentric2D(vec2 p, vec2 v0, vec2 v1, vec2 v2) {\n"
    "    vec2 e0 = v1 - v0;\n"
    "    vec2 e1 = v2 - v0;\n"
    "    vec2 e2 = p - v0;\n"
    "    float d00 = dot(e0, e0);\n"
    "    float d01 = dot(e0, e1);\n"
    "    float d11 = dot(e1, e1);\n"
    "    float d20 = dot(e2, e0);\n"
    "    float d21 = dot(e2, e1);\n"
    "    float denom = d00 * d11 - d01 * d01;\n"
    "    if (abs(denom) < 1e-6) return vec3(1.0, 0.0, 0.0);\n" // Degenerate triangle fallback
    "    float u = (d11 * d20 - d01 * d21) / denom;\n"
    "    float v = (d00 * d21 - d01 * d20) / denom;\n"
    "    return vec3(1.0 - u - v, u, v);\n"
    "}\n"

    // Main compute shader
    "void main() {\n"
    "    uint luxelIdx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_WorkGroupSize.x * gl_NumWorkGroups.x;\n"
    "    if (luxelIdx >= totalLuxelCount) return;\n"

    // Find the model and triangle for this luxel
    "    uint modelIdx = 0;\n"
    "    uint triIdx = 0;\n"
    "    uint luxelOffset = 0;\n"
    "    for (uint i = 0; i < 768; i++) {\n"
    "        if (i + 1 >= 769) break;\n" // Prevent out-of-bounds access
    "        if (luxelIdx < uint(lightmapLuxelOffsets[i + 1])) {\n"
    "            modelIdx = i;\n"
    "            luxelOffset = uint(lightmapLuxelOffsets[i]);\n"
    "            break;\n"
    "        }\n"
    "    }\n"
    "    if (modelIdx == 0 && luxelIdx >= uint(lightmapLuxelOffsets[0])) {\n"
    "        luxelData[luxelIdx * 4 + 0] = 1.0;\n" // Debug: Red for invalid modelIdx
    "        luxelData[luxelIdx * 4 + 1] = 0.0;\n"
    "        luxelData[luxelIdx * 4 + 2] = 0.0;\n"
    "        luxelData[luxelIdx * 4 + 3] = 1.0;\n"
    "        return;\n"
    "    }\n"
    "    uint localLuxelIdx = luxelIdx - luxelOffset;\n"
    "    uint triOffset = 0;\n"
    "    for (uint i = 0; i < triangleCounts[modelIdx]; i++) {\n"
    "        uint triLuxelOffset = uint(triLuxelMetaData[modelIdx * triangleCounts[modelIdx] * 3 + i * 3]);\n"
    "        uint luxel_u = uint(triLuxelMetaData[modelIdx * triangleCounts[modelIdx] * 3 + i * 3 + 1]);\n"
    "        uint luxel_v = uint(triLuxelMetaData[modelIdx * triangleCounts[modelIdx] * 3 + i * 3 + 2]);\n"
    "        uint triLuxelCount = luxel_u * luxel_v;\n"
    "        if (localLuxelIdx < triLuxelOffset + triLuxelCount) {\n"
    "            triIdx = i;\n"
    "            localLuxelIdx -= triLuxelOffset;\n"
    "            break;\n"
    "        }\n"
    "    }\n"

    // Compute luxel UV coordinates within the triangle
    "    uint luxel_u = uint(triLuxelMetaData[modelIdx * triangleCounts[modelIdx] * 3 + triIdx * 3 + 1]);\n"
    "    uint luxel_v = uint(triLuxelMetaData[modelIdx * triangleCounts[modelIdx] * 3 + triIdx * 3 + 2]);\n"
    "    uint luxelIdxU = localLuxelIdx % luxel_u;\n"
    "    uint luxelIdxV = localLuxelIdx / luxel_u;\n"
    "    float u = (float(luxelIdxU) + 0.5) / float(luxel_u);\n"
    "    float v = (float(luxelIdxV) + 0.5) / float(luxel_v);\n"

    // Get triangle vertices and compute luxel position/normal
    "    uint v0Idx = triangles[modelIdx * triangleCounts[modelIdx] * 3 + triIdx * 3 + 0];\n"
    "    uint v1Idx = triangles[modelIdx * triangleCounts[modelIdx] * 3 + triIdx * 3 + 1];\n"
    "    uint v2Idx = triangles[modelIdx * triangleCounts[modelIdx] * 3 + triIdx * 3 + 2];\n"
    "    vec3 v0 = vec3(vertices[v0Idx * VERTEX_ATTRIBUTES_COUNT + 0],\n"
    "                   vertices[v0Idx * VERTEX_ATTRIBUTES_COUNT + 1],\n"
    "                   vertices[v0Idx * VERTEX_ATTRIBUTES_COUNT + 2]);\n"
    "    vec3 v1 = vec3(vertices[v1Idx * VERTEX_ATTRIBUTES_COUNT + 0],\n"
    "                   vertices[v1Idx * VERTEX_ATTRIBUTES_COUNT + 1],\n"
    "                   vertices[v1Idx * VERTEX_ATTRIBUTES_COUNT + 2]);\n"
    "    vec3 v2 = vec3(vertices[v2Idx * VERTEX_ATTRIBUTES_COUNT + 0],\n"
    "                   vertices[v2Idx * VERTEX_ATTRIBUTES_COUNT + 1],\n"
    "                   vertices[v2Idx * VERTEX_ATTRIBUTES_COUNT + 2]);\n"
    "    vec3 n0 = vec3(vertices[v0Idx * VERTEX_ATTRIBUTES_COUNT + 3],\n"
    "                   vertices[v0Idx * VERTEX_ATTRIBUTES_COUNT + 4],\n"
    "                   vertices[v0Idx * VERTEX_ATTRIBUTES_COUNT + 5]);\n"
    "    vec3 n1 = vec3(vertices[v1Idx * VERTEX_ATTRIBUTES_COUNT + 3],\n"
    "                   vertices[v1Idx * VERTEX_ATTRIBUTES_COUNT + 4],\n"
    "                   vertices[v1Idx * VERTEX_ATTRIBUTES_COUNT + 5]);\n"
    "    vec3 n2 = vec3(vertices[v2Idx * VERTEX_ATTRIBUTES_COUNT + 3],\n"
    "                   vertices[v2Idx * VERTEX_ATTRIBUTES_COUNT + 4],\n"
    "                   vertices[v2Idx * VERTEX_ATTRIBUTES_COUNT + 5]);\n"
    "    vec2 uv0 = vec2(vertices[v0Idx * VERTEX_ATTRIBUTES_COUNT + 13],\n"
    "                    vertices[v0Idx * VERTEX_ATTRIBUTES_COUNT + 14]);\n"
    "    vec2 uv1 = vec2(vertices[v1Idx * VERTEX_ATTRIBUTES_COUNT + 13],\n"
    "                    vertices[v1Idx * VERTEX_ATTRIBUTES_COUNT + 14]);\n"
    "    vec2 uv2 = vec2(vertices[v2Idx * VERTEX_ATTRIBUTES_COUNT + 13],\n"
    "                    vertices[v2Idx * VERTEX_ATTRIBUTES_COUNT + 14]);\n"

    // Interpolate position and normal using barycentric coordinates
    "    vec3 bary = Barycentric2D(vec2(u, v), uv0, uv1, uv2);\n"
    "    vec3 luxelPos = v0 * bary.x + v1 * bary.y + v2 * bary.z;\n"
    "    vec3 luxelNormal = normalize(n0 * bary.x + n1 * bary.y + n2 * bary.z);\n"

    // Apply instance transformation (use instance 0 for model-based lightmap)
    "    mat4 instanceMatrix = instanceMatrices[0];\n"
    "    vec4 worldPos = instanceMatrix * vec4(luxelPos, 1.0);\n"
    "    vec3 worldNormal = normalize((instanceMatrix * vec4(luxelNormal, 0.0)).xyz);\n"

    // Accumulate lighting
    "    vec3 lighting = vec3(0.0);\n"
    "    for (uint i = 0; i < MAX_VISIBLE_LIGHTS; i++) {\n"
    "        uint lightIdx = i * LIGHT_DATA_SIZE;\n"
    "        float intensity = lightInPVS[lightIdx + LIGHT_DATA_OFFSET_INTENSITY];\n"
    "        if (intensity < 0.05) continue;\n"
    "        vec3 lightPos = vec3(lightInPVS[lightIdx + LIGHT_DATA_OFFSET_POSX],\n"
    "                             lightInPVS[lightIdx + LIGHT_DATA_OFFSET_POSY],\n"
    "                             lightInPVS[lightIdx + LIGHT_DATA_OFFSET_POSZ]);\n"
    "        vec3 lightColor = vec3(lightInPVS[lightIdx + LIGHT_DATA_OFFSET_R],\n"
    "                               lightInPVS[lightIdx + LIGHT_DATA_OFFSET_G],\n"
    "                               lightInPVS[lightIdx + LIGHT_DATA_OFFSET_B]);\n"
    "        float range = lightInPVS[lightIdx + LIGHT_DATA_OFFSET_RANGE];\n"
    "        vec3 toLight = lightPos - worldPos.xyz;\n"
    "        float dist = length(toLight);\n"
    "        if (dist > range) continue;\n"
    "        vec3 lightDir = normalize(toLight);\n"
    "        float lambertian = max(dot(worldNormal, lightDir), 0.0);\n"
    "        if (lambertian < 0.25) continue;\n"

    // Check for occlusion
    "        bool occluded = false;\n"
    "        for (uint j = 0; j < instanceCount; j++) {\n"
    "            uint instIdx = instancesIndices[j];\n"
    "            if (instIdx >= instanceCount) continue;\n"
    "            uint instModelIdx = uint(instances[instIdx].modelIndex);\n"
    "            if (instModelIdx >= 768) continue;\n"
    "            mat4 instMatrix = instanceMatrices[instIdx];\n"
    "            for (uint t = 0; t < triangleCounts[instModelIdx]; t++) {\n"
    "                uint tIdx0 = triangles[instModelIdx * triangleCounts[instModelIdx] * 3 + t * 3 + 0];\n"
    "                uint tIdx1 = triangles[instModelIdx * triangleCounts[instModelIdx] * 3 + t * 3 + 1];\n"
    "                uint tIdx2 = triangles[instModelIdx * triangleCounts[instModelIdx] * 3 + t * 3 + 2];\n"
    "                vec3 t0 = vec3(vertices[tIdx0 * VERTEX_ATTRIBUTES_COUNT + 0],\n"
    "                               vertices[tIdx0 * VERTEX_ATTRIBUTES_COUNT + 1],\n"
    "                               vertices[tIdx0 * VERTEX_ATTRIBUTES_COUNT + 2]);\n"
    "                vec3 t1 = vec3(vertices[tIdx1 * VERTEX_ATTRIBUTES_COUNT + 0],\n"
    "                               vertices[tIdx1 * VERTEX_ATTRIBUTES_COUNT + 1],\n"
    "                               vertices[tIdx1 * VERTEX_ATTRIBUTES_COUNT + 2]);\n"
    "                vec3 t2 = vec3(vertices[tIdx2 * VERTEX_ATTRIBUTES_COUNT + 0],\n"
    "                               vertices[tIdx2 * VERTEX_ATTRIBUTES_COUNT + 1],\n"
    "                               vertices[tIdx2 * VERTEX_ATTRIBUTES_COUNT + 2]);\n"
    "                vec4 wt0 = instMatrix * vec4(t0, 1.0);\n"
    "                vec4 wt1 = instMatrix * vec4(t1, 1.0);\n"
    "                vec4 wt2 = instMatrix * vec4(t2, 1.0);\n"
    "                float tHit;\n"
    "                if (RayTriangle(worldPos.xyz, lightDir, wt0.xyz, wt1.xyz, wt2.xyz, tHit) && tHit < dist) {\n"
    "                    occluded = true;\n"
    "                    break;\n"
    "                }\n"
    "            }\n"
    "            if (occluded) break;\n"
    "        }\n"
    "        if (!occluded) {\n"
    "            float attenuation = 1.0 / (1.0 + 0.1 * dist + 0.01 * dist * dist);\n"
    "            lighting += lightColor * intensity * lambertian * attenuation;\n"
    "        }\n"
    "    }\n"

    // Write to lightmap
    "    luxelData[luxelIdx * 4 + 0] = lighting.r;\n"
    "    luxelData[luxelIdx * 4 + 1] = lighting.g;\n"
    "    luxelData[luxelIdx * 4 + 2] = lighting.b;\n"
    "    luxelData[luxelIdx * 4 + 3] = 1.0;\n"
    "}\n";
