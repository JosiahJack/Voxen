const char* lightmap_compute_shader = 
    "#version 450 core\n"
    "layout(local_size_x = 32, local_size_y = 32) in;\n"

    // binding 0 unusable here, in-out gbuffer for colors (reflections applied as well in separate pass)
    // binding 1 unusable here, unlit raster's gbuffer for world position xyz as rgb (RGBA32F), index into full instances[] array packed into alpha channel
    // binding 2 unusable here, unlit raster's gbuffer for normals xyz half loats packed in rg
    // binding 3 unused at all, unlit raster's gbuffer for depth (placeholder, using renderbuffer for now as this isn't needed with having world position gbuffer on binding point 1)
    // binding 4 unusable here, ssr's output color downsized from main resolution
    // binding 5 unused at all, placeholder for possible future gbuffer if needed
    "layout(std430, binding = 6) buffer LightmapData { float lightmapData[]; };\n"
    "layout(std430, binding = 7) buffer BoundsBuffer { float bounds[]; };\n"
    "layout(std430, binding = 11) readonly buffer InstancesMatricesBuffer { mat4 instanceMatrices[]; };\n"
    "layout(std430, binding = 12) buffer ColorBuffer { uint colors[]; };\n" // 1D color array (RGBA)
    "layout(std430, binding = 14) buffer TextureOffsets { uint textureOffsets[]; };\n" // Starting index in colors for each texture
    "layout(std430, binding = 15) buffer TextureSizes { ivec2 textureSizes[]; };\n" // x,y pairs for width and height of textures
    "layout(std430, binding = 16) buffer TexturePalettes { uint texturePalettes[]; };\n" // Palette colors
    "layout(std430, binding = 17) buffer TexturePaletteOffsets { uint texturePaletteOffsets[]; };\n" // Palette starting indices for each texture
    "layout(std430, binding = 18) readonly buffer VertexData { float vboMasterTable[]; };\n"
    "layout(std430, binding = 19) buffer LightData { float lights[]; };\n" // Full list of all lights, no PVS for lightmapping (normally this is just lights in player's PVS)
    "layout(std430, binding = 21) readonly buffer TriangleCounts { uint triangleCounts[]; };\n"
    "layout(std430, binding = 22) readonly buffer TriangleOffsets { uint triangleOffsets[]; };\n"
    "layout(std430, binding = 23) readonly buffer TriangleData { uint tboMasterTable[]; };\n"
    "layout(std430, binding = 24) readonly buffer VertexCounts { uint vertexCounts[]; };\n"
    "layout(std430, binding = 25) readonly buffer VertexOffsets { uint vertexOffsets[]; };\n"

    "uniform uint totalLuxelCount;\n"
    "uniform uint instanceCount;\n"
    "uniform uint modelCount;\n"
    "uniform uint lightCount;\n"
    "uniform float worldMin_x;\n" // Min position x,z for getting cell coordinates in the 64 x 64 world cells,
    "uniform float worldMin_z;\n" // used for precomputedVisibleCellsFromHere coarse culling
    "const int MAX_VISIBLE_LIGHTS = 90;\n"
    "const int LIGHT_DATA_SIZE = 13;\n"
    "const int LIGHT_DATA_OFFSET_POSX = 0;\n"
    "const int LIGHT_DATA_OFFSET_POSY = 1;\n"
    "const int LIGHT_DATA_OFFSET_POSZ = 2;\n"
    "const int LIGHT_DATA_OFFSET_INTENSITY = 3;\n"
    "const int LIGHT_DATA_OFFSET_RANGE = 4;\n"
    "const int LIGHT_DATA_OFFSET_R = 10;\n"
    "const int LIGHT_DATA_OFFSET_G = 11;\n"
    "const int LIGHT_DATA_OFFSET_B = 12;\n"
    "const float WORLDCELL_WIDTH_F = 2.56;\n"
    "const float CELLXHALF = 1.28;\n"
    "const int VERTEX_ATTRIBUTES_COUNT = 16;\n"
    "const int BOUNDS_ATTRIBUTES_COUNT = 7;\n"
    "const int BOUNDS_DATA_OFFSET_MINX = 0;\n"
    "const int BOUNDS_DATA_OFFSET_MINY = 1;\n"
    "const int BOUNDS_DATA_OFFSET_MINZ = 2;\n"
    "const int BOUNDS_DATA_OFFSET_MAXX = 3;\n"
    "const int BOUNDS_DATA_OFFSET_MAXY = 4;\n"
    "const int BOUNDS_DATA_OFFSET_MAXZ = 5;\n"
    "const int VERTEX_OFFSET_POSX = 0;\n"
    "const int VERTEX_OFFSET_POSY = 1;\n"
    "const int VERTEX_OFFSET_POSZ = 2;\n"
    "const int VERTEX_OFFSET_NORX = 3;\n"
    "const int VERTEX_OFFSET_NORY = 4;\n"
    "const int VERTEX_OFFSET_NORZ = 5;\n"
    "const int VERTEX_OFFSET_U = 6;\n"
    "const int VERTEX_OFFSET_V = 7;\n"
    "const int VERTEX_OFFSET_TEXINDEX = 8;\n"
    "const int VERTEX_OFFSET_GLOWINDEX = 9;\n"
    "const int VERTEX_OFFSET_SPECINDEX = 10;\n"
    "const int VERTEX_OFFSET_NORMINDEX = 11;\n"
    "const int VERTEX_OFFSET_MODELINDEX = 12;\n"
    "const int VERTEX_OFFSET_INSTANCEINDEX = 13;\n"
    "const int VERTEX_OFFSET_U_LM = 14;\n"
    "const int VERTEX_OFFSET_V_LM = 15;\n"

    "vec4 getTextureColor(uint texIndex, ivec2 texCoord) {\n"
    "    if (texIndex >= 65535) return vec4(0.0);\n"

    "    uint pixelOffset = textureOffsets[texIndex] + texCoord.y * textureSizes[texIndex].x + texCoord.x;\n"
    "    uint slotIndex = pixelOffset / 2;\n"
    "    uint packedIdx = colors[slotIndex];\n"
    "    uint paletteIndex = (pixelOffset % 2 == 0) ? (packedIdx & 0xFFFF) : (packedIdx >> 16);\n"
    "    uint paletteOffset = texturePaletteOffsets[texIndex];\n"
    "    uint color = texturePalettes[paletteOffset + paletteIndex];\n"
    "    return vec4(\n"
    "        float((color >> 24) & 0xFF) / 255.0,\n"
    "        float((color >> 16) & 0xFF) / 255.0,\n"
    "        float((color >> 8) & 0xFF) / 255.0,\n"
    "        float(color & 0xFF) / 255.0\n"
    "    );\n"
    "}\n"

    "uvec2 PosToCellCoords(float pos_x, float pos_z) {\n"
    "    uvec2 retval;\n"
    "    retval.x = uint(int((pos_x - worldMin_x + CELLXHALF) / WORLDCELL_WIDTH_F));\n"
    "    retval.y = uint(int((pos_z - worldMin_z + CELLXHALF) / WORLDCELL_WIDTH_F));\n"
    "    return retval;\n"
    "}\n"

    "vec3 fetchVertexPos(uint globalVertexIndex) {\n"
    "     uint base = globalVertexIndex * uint(VERTEX_ATTRIBUTES_COUNT);\n"
    "     return vec3(vboMasterTable[base + VERTEX_OFFSET_POSX], vboMasterTable[base + VERTEX_OFFSET_POSY], vboMasterTable[base + VERTEX_OFFSET_POSZ]);\n"
    "}\n"

    "vec3 fetchVertexNor(uint globalVertexIndex) {\n"
    "     uint base = globalVertexIndex * uint(VERTEX_ATTRIBUTES_COUNT);\n"
    "     return normalize(vec3(vboMasterTable[base + VERTEX_OFFSET_NORX], vboMasterTable[base + VERTEX_OFFSET_NORY], vboMasterTable[base + VERTEX_OFFSET_NORZ]));\n"
    "}\n"

    "vec2 fetchVertexUV(uint globalVertexIndex) {\n"
    "     uint base = globalVertexIndex * uint(VERTEX_ATTRIBUTES_COUNT);\n"
    "     return vec2(vboMasterTable[base + VERTEX_OFFSET_U], vboMasterTable[base + VERTEX_OFFSET_V]);\n"
    "}\n"

    // Ray-Triangle Intersection (MÃ¶ller-Trumbore)
    "bool RayTriangle(vec3 origin, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out float t) {\n"
    "    vec3 edge1 = v1 - v0;\n"
    "    vec3 edge2 = v2 - v0;\n"
    "    vec3 h = cross(dir, edge2);\n"
    "    float a = dot(edge1, h);\n"
    "    if (abs(a) < 1e-6) return false;\n"

    "    float f = 1.0 / a;\n"
    "    vec3 s = origin - v0;\n"
    "    float u = f * dot(s, h);\n"
    "    if (u < 0.0 || u > 1.0) return false;\n"

    "    vec3 q = cross(s, edge1);\n"
    "    float v = f * dot(dir, q);\n"
    "    if (v < 0.0 || u + v > 1.0) return false;\n"

    "    t = f * dot(edge2, q);\n"
    "    return t > 0.001;\n"
    "}\n"

    // Compute barycentric coordinates in 2D UV space
    "vec3 Barycentric2D(vec2 p, vec2 v0, vec2 v1, vec2 v2) {\n"
    "    vec2 e0 = v1 - v0;\n"
    "    vec2 e1 = v2 - v0;\n"
    "    vec2 e2 = p - v0;\n"
    "    float d00 = dot(e0, e0);\n"
    "    float d01 = dot(e0, e1);\n"
    "    float d11 = dot(e1, e1);\n"
    "    float d20 = dot(e2, e0);\n"
    "    float d21 = dot(e2, e1);\n"
    "    float denom = d00 * d11 - d01 * d01;\n"
    "    if (abs(denom) < 1e-6) return vec3(1.0, 0.0, 0.0);\n"

    "    float u = (d11 * d20 - d01 * d21) / denom;\n"
    "    float v = (d00 * d21 - d01 * d20) / denom;\n"
    "    return vec3(1.0 - u - v, u, v);\n"
    "}\n"

    "void main() {\n"
     " uvec2 gid = gl_GlobalInvocationID.xy;\n"
     " uint tilesX = 12;\n"
     " uint globalWidth = tilesX * 64u;\n"
     " uint globalIndex = gid.y * globalWidth + gid.x;\n"
     " if (globalIndex >= totalLuxelCount) return;\n"

     " uint tileX = gid.x / 64u;\n"
     " uint tileY = gid.y / 64u;\n"
     " uint tileIndex = tileY * tilesX + tileX;\n"

     " uint lx = gid.x % 64u;\n"
     " uint ly = gid.y % 64u;\n"
     " float fx = float(lx) / 63.0;\n"
     " float fy = float(ly) / 63.0;\n"
     " vec3 color = vec3(fx, fy, 0.5 * (fx + fy));\n"
     " float tileTint = float(tileIndex % 256u) / 255.0;\n"
     " color = fract(color + vec3(tileTint * 0.15, tileTint * 0.30, tileTint * 0.45));\n"

     " uint writeIndex = globalIndex * 4u;\n"
     " lightmapData[writeIndex + 0u] = color.r;\n"
     " lightmapData[writeIndex + 1u] = color.g;\n"
     " lightmapData[writeIndex + 2u] = color.b;\n"
     " lightmapData[writeIndex + 3u] = 1.0;\n"
    "}\n";
