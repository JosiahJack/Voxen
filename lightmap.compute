const char* lightmap_compute_shader = 
    "#version 450 core\n"
    "layout(local_size_x = 32, local_size_y = 1) in;\n"

    "struct Instance {\n"
    "    int modelIndex;\n"
    "    int texIndex;\n"
    "    int glowIndex;\n"
    "    int specIndex;\n"
    "    int normIndex;\n"
    "    int lodIndex;\n"
    "    float posx;\n"
    "    float posy;\n"
    "    float posz;\n"
    "    float sclx;\n"
    "    float scly;\n"
    "    float sclz;\n"
    "    float rotx;\n"
    "    float roty;\n"
    "    float rotz;\n"
    "    float rotw;\n"
    "    float floorHeight;\n"
    "};\n"

    // binding 0 unusable here, in-out gbuffer for colors (starts as unlit, gets deferred lighting and reflections applied in separate passes)
    // binding 1 unusable here, unlit raster's gbuffer for world position xyz as rgb (RGBA32F), index into full instances[] array packed into alpha channel
    // binding 2 unusable here, unlit raster's gbuffer for normals xyz half loats packed in rg
    // binding 3 unused at all, unlit raster's gbuffer for depth (placeholder, using renderbuffer for now as this isn't needed with having world position gbuffer on binding point 1)
    // binding 4 unusable here, deferred lighting's output color after applying lighting and screenspace reflections
    // binding 5 unused at all, placeholder for possible future gbuffer if needed
    "layout(std430, binding = 6) buffer LightmapData { float lightmapData[]; };\n"
    "layout(std430, binding = 7) buffer BoundsBuffer { float bounds[]; };\n"
    "layout(std430, binding = 10) readonly buffer InstancesBuffer { Instance instances[]; };\n"
    "layout(std430, binding = 11) readonly buffer InstancesMatricesBuffer { mat4 instanceMatrices[]; };\n"
    "layout(std430, binding = 12) buffer ColorBuffer { uint colors[]; };\n" // 1D color array (RGBA)
    "layout(std430, binding = 14) buffer TextureOffsets { uint textureOffsets[]; };\n" // Starting index in colors for each texture
    "layout(std430, binding = 15) buffer TextureSizes { ivec2 textureSizes[]; };\n" // x,y pairs for width and height of textures
    "layout(std430, binding = 16) buffer TexturePalettes { uint texturePalettes[]; };\n" // Palette colors
    "layout(std430, binding = 17) buffer TexturePaletteOffsets { uint texturePaletteOffsets[]; };\n" // Palette starting indices for each texture
    "layout(std430, binding = 18) readonly buffer VertexData { float vboMasterTable[]; };\n"
    "layout(std430, binding = 19) buffer LightData { float lights[]; };\n" // Full list of all lights, no PVS for lightmapping (normally this is just lights in player's PVS)
    "layout(std430, binding = 21) readonly buffer TriangleCounts { uint triangleCounts[]; };\n"
    "layout(std430, binding = 22) readonly buffer TriangleOffsets { uint triangleOffsets[]; };\n"
    "layout(std430, binding = 23) readonly buffer TriangleData { uint tboMasterTable[]; };\n"
    "layout(std430, binding = 24) readonly buffer VertexCounts { uint vertexCounts[]; };\n"
    "layout(std430, binding = 25) readonly buffer VertexOffsets { uint vertexOffsets[]; };\n"

    "uniform uint totalLuxelCount;\n"
    "uniform uint instanceCount;\n"
    "uniform uint modelCount;\n"
    "uniform uint lightCount;\n"
    "uniform float worldMin_x;\n" // Min position x,z for getting cell coordinates in the 64 x 64 world cells,
    "uniform float worldMin_z;\n" // used for precomputedVisibleCellsFromHere coarse culling
    "const int MAX_VISIBLE_LIGHTS = 90;\n"
    "const int LIGHT_DATA_SIZE = 13;\n"
    "const int LIGHT_DATA_OFFSET_POSX = 0;\n"
    "const int LIGHT_DATA_OFFSET_POSY = 1;\n"
    "const int LIGHT_DATA_OFFSET_POSZ = 2;\n"
    "const int LIGHT_DATA_OFFSET_INTENSITY = 3;\n"
    "const int LIGHT_DATA_OFFSET_RANGE = 4;\n"
    "const int LIGHT_DATA_OFFSET_R = 10;\n"
    "const int LIGHT_DATA_OFFSET_G = 11;\n"
    "const int LIGHT_DATA_OFFSET_B = 12;\n"
    "const float WORLDCELL_WIDTH_F = 2.56;\n"
    "const float CELLXHALF = 1.28;\n"
    "const int VERTEX_ATTRIBUTES_COUNT = 16;\n"
    "const int BOUNDS_ATTRIBUTES_COUNT = 7;\n"
    "const int BOUNDS_DATA_OFFSET_MINX = 0;\n"
    "const int BOUNDS_DATA_OFFSET_MINY = 1;\n"
    "const int BOUNDS_DATA_OFFSET_MINZ = 2;\n"
    "const int BOUNDS_DATA_OFFSET_MAXX = 3;\n"
    "const int BOUNDS_DATA_OFFSET_MAXY = 4;\n"
    "const int BOUNDS_DATA_OFFSET_MAXZ = 5;\n"
    "const int VERTEX_OFFSET_POSX = 0;\n"
    "const int VERTEX_OFFSET_POSY = 1;\n"
    "const int VERTEX_OFFSET_POSZ = 2;\n"
    "const int VERTEX_OFFSET_NORX = 3;\n"
    "const int VERTEX_OFFSET_NORY = 4;\n"
    "const int VERTEX_OFFSET_NORZ = 5;\n"
    "const int VERTEX_OFFSET_U = 6;\n"
    "const int VERTEX_OFFSET_V = 7;\n"
    "const int VERTEX_OFFSET_TEXINDEX = 8;\n"
    "const int VERTEX_OFFSET_GLOWINDEX = 9;\n"
    "const int VERTEX_OFFSET_SPECINDEX = 10;\n"
    "const int VERTEX_OFFSET_NORMINDEX = 11;\n"
    "const int VERTEX_OFFSET_MODELINDEX = 12;\n"
    "const int VERTEX_OFFSET_INSTANCEINDEX = 13;\n"
    "const int VERTEX_OFFSET_U_LM = 14;\n"
    "const int VERTEX_OFFSET_V_LM = 15;\n"

    "vec4 getTextureColor(uint texIndex, ivec2 texCoord) {\n"
    "    if (texIndex >= 65535) return vec4(0.0);\n"

    "    uint pixelOffset = textureOffsets[texIndex] + texCoord.y * textureSizes[texIndex].x + texCoord.x;\n"
    "    uint slotIndex = pixelOffset / 2;\n"
    "    uint packedIdx = colors[slotIndex];\n"
    "    uint paletteIndex = (pixelOffset % 2 == 0) ? (packedIdx & 0xFFFF) : (packedIdx >> 16);\n"
    "    uint paletteOffset = texturePaletteOffsets[texIndex];\n"
    "    uint color = texturePalettes[paletteOffset + paletteIndex];\n"
    "    return vec4(\n"
    "        float((color >> 24) & 0xFF) / 255.0,\n"
    "        float((color >> 16) & 0xFF) / 255.0,\n"
    "        float((color >> 8) & 0xFF) / 255.0,\n"
    "        float(color & 0xFF) / 255.0\n"
    "    );\n"
    "}\n"

    "uvec2 PosToCellCoords(float pos_x, float pos_z) {\n"
    "    uvec2 retval;\n"
    "    retval.x = uint(int((pos_x - worldMin_x + CELLXHALF) / WORLDCELL_WIDTH_F));\n"
    "    retval.y = uint(int((pos_z - worldMin_z + CELLXHALF) / WORLDCELL_WIDTH_F));\n"
    "    return retval;\n"
    "}\n"

    "vec3 fetchVertexPos(uint globalVertexIndex) {\n"
    "     uint base = globalVertexIndex * uint(VERTEX_ATTRIBUTES_COUNT);\n"
    "     return vec3(vboMasterTable[base + VERTEX_OFFSET_POSX], vboMasterTable[base + VERTEX_OFFSET_POSY], vboMasterTable[base + VERTEX_OFFSET_POSZ]);\n"
    "}\n"

    "vec3 fetchVertexNor(uint globalVertexIndex) {\n"
    "     uint base = globalVertexIndex * uint(VERTEX_ATTRIBUTES_COUNT);\n"
    "     return normalize(vec3(vboMasterTable[base + VERTEX_OFFSET_NORX], vboMasterTable[base + VERTEX_OFFSET_NORY], vboMasterTable[base + VERTEX_OFFSET_NORZ]));\n"
    "}\n"

    "vec2 fetchVertexUV(uint globalVertexIndex) {\n"
    "     uint base = globalVertexIndex * uint(VERTEX_ATTRIBUTES_COUNT);\n"
    "     return vec2(vboMasterTable[base + VERTEX_OFFSET_U], vboMasterTable[base + VERTEX_OFFSET_V]);\n"
    "}\n"

    // Ray-Triangle Intersection (MÃ¶ller-Trumbore)
    "bool RayTriangle(vec3 origin, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out float t) {\n"
    "    vec3 edge1 = v1 - v0;\n"
    "    vec3 edge2 = v2 - v0;\n"
    "    vec3 h = cross(dir, edge2);\n"
    "    float a = dot(edge1, h);\n"
    "    if (abs(a) < 1e-6) return false;\n"

    "    float f = 1.0 / a;\n"
    "    vec3 s = origin - v0;\n"
    "    float u = f * dot(s, h);\n"
    "    if (u < 0.0 || u > 1.0) return false;\n"

    "    vec3 q = cross(s, edge1);\n"
    "    float v = f * dot(dir, q);\n"
    "    if (v < 0.0 || u + v > 1.0) return false;\n"

    "    t = f * dot(edge2, q);\n"
    "    return t > 0.001;\n"
    "}\n"

    // Compute barycentric coordinates in 2D UV space
    "vec3 Barycentric2D(vec2 p, vec2 v0, vec2 v1, vec2 v2) {\n"
    "    vec2 e0 = v1 - v0;\n"
    "    vec2 e1 = v2 - v0;\n"
    "    vec2 e2 = p - v0;\n"
    "    float d00 = dot(e0, e0);\n"
    "    float d01 = dot(e0, e1);\n"
    "    float d11 = dot(e1, e1);\n"
    "    float d20 = dot(e2, e0);\n"
    "    float d21 = dot(e2, e1);\n"
    "    float denom = d00 * d11 - d01 * d01;\n"
    "    if (abs(denom) < 1e-6) return vec3(1.0, 0.0, 0.0);\n"

    "    float u = (d11 * d20 - d01 * d21) / denom;\n"
    "    float v = (d00 * d21 - d01 * d20) / denom;\n"
    "    return vec3(1.0 - u - v, u, v);\n"
    "}\n"

     "void main() {\n"
     "    uint gid = gl_GlobalInvocationID.x;\n"
     "    if (gid >= totalLuxelCount) return;\n"
     "\n"
     "    // Figure out which instance this luxel belongs to\n"
     "    uint instanceIndex = gid / (64u * 64u);\n"
     "    uint localLuxel = gid % (64u * 64u);\n"
     "    uint lx = localLuxel % 64u;\n"
     "    uint ly = localLuxel / 64u;\n"
     "\n"
     "    // Lookup instance transform\n"
     "    mat4 modelMat = instanceMatrices[instanceIndex];\n"
     "\n"
     "    // For now just placeholder lighting accumulation\n"
     "    vec3 accumLight = vec3(0.0);\n"
     "    for (uint l = 0u; l < lightCount; ++l) {\n"
     "        uint base = l * LIGHT_DATA_SIZE;\n"
     "        vec3 pos = vec3(lights[base+0], lights[base+1], lights[base+2]);\n"
     "        float intensity = lights[base+3];\n"
     "        float r = length(pos);\n"
     "        accumLight += vec3(intensity) / (1.0 + r*r);\n"
     "    }\n"
     "\n"
     "    // Write out to lightmap buffer\n"
     "    uint writeIndex = gid * 4u;\n"
     "    lightmapData[writeIndex+0] = accumLight.r;\n"
     "    lightmapData[writeIndex+1] = accumLight.g;\n"
     "    lightmapData[writeIndex+2] = accumLight.b;\n"
     "    lightmapData[writeIndex+3] = 1.0;\n"
     "}\n";

