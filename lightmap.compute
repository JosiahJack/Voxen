const char* lightmap_compute_shader = 
    "#version 450 core\n"
    "layout(local_size_x = 32, local_size_y = 1) in;\n"

    "struct Instance {\n"
    "    int modelIndex;\n"
    "    int texIndex;\n"
    "    int glowIndex;\n"
    "    int specIndex;\n"
    "    int normIndex;\n"
    "    int lodIndex;\n"
    "    float posx;\n"
    "    float posy;\n"
    "    float posz;\n"
    "    float sclx;\n"
    "    float scly;\n"
    "    float sclz;\n"
    "    float rotx;\n"
    "    float roty;\n"
    "    float rotz;\n"
    "    float rotw;\n"
    "    float floorHeight;\n"
    "};\n"

    "layout(std430, binding = 7) buffer BoundsBuffer { float bounds[]; };\n"
    "layout(std430, binding = 10) readonly buffer InstancesBuffer { Instance instances[]; };\n"
    "layout(std430, binding = 11) readonly buffer InstancesMatricesBuffer { mat4 instanceMatrices[]; };\n"
    "layout(std430, binding = 19) buffer LightIndices { float lightInPVS[]; };\n"
    "layout(std430, binding = 21) buffer LightmapLuxelData { float luxelData[]; };\n"
    "layout(std430, binding = 22) readonly buffer LightmapOffsets { uint lightmapLuxelOffsets[]; };\n"
    "layout(std430, binding = 23) readonly buffer TriLuxel { uint triLuxelMetaData[]; };\n"
    "layout(std430, binding = 26) readonly buffer VertexData { float vboMasterTable[]; };\n"
    "layout(std430, binding = 27) readonly buffer TriangleData { uint tboMasterTable[]; };\n"
    "layout(std430, binding = 28) readonly buffer VertexCounts { uint vertexCounts[]; };\n"
    "layout(std430, binding = 29) readonly buffer TriangleCounts { uint triangleCounts[]; };\n"
    "layout(std430, binding = 30) readonly buffer VertexOffsets { uint vertexOffsets[]; };\n"
    "layout(std430, binding = 31) readonly buffer TriangleOffsets { uint triangleOffsets[]; };\n"

    "uniform uint totalLuxelCount;\n"
    "uniform uint instanceCount;\n"
    "uniform uint modelCount;\n"
    "const int MAX_VISIBLE_LIGHTS = 90;\n"
    "const int LIGHT_DATA_SIZE = 13;\n"
    "const int LIGHT_DATA_OFFSET_POSX = 0;\n"
    "const int LIGHT_DATA_OFFSET_POSY = 1;\n"
    "const int LIGHT_DATA_OFFSET_POSZ = 2;\n"
    "const int LIGHT_DATA_OFFSET_INTENSITY = 3;\n"
    "const int LIGHT_DATA_OFFSET_RANGE = 4;\n"
    "const int LIGHT_DATA_OFFSET_R = 10;\n"
    "const int LIGHT_DATA_OFFSET_G = 11;\n"
    "const int LIGHT_DATA_OFFSET_B = 12;\n"
    "const int VERTEX_ATTRIBUTES_COUNT = 16;\n"
    "const int BOUNDS_ATTRIBUTES_COUNT = 7;\n"
    "const int BOUNDS_DATA_OFFSET_MINX = 0;\n"
    "const int BOUNDS_DATA_OFFSET_MINY = 1;\n"
    "const int BOUNDS_DATA_OFFSET_MINZ = 2;\n"
    "const int BOUNDS_DATA_OFFSET_MAXX = 3;\n"
    "const int BOUNDS_DATA_OFFSET_MAXY = 4;\n"
    "const int BOUNDS_DATA_OFFSET_MAXZ = 5;\n"
    "const int VERTEX_OFFSET_POSX = 0;\n"
    "const int VERTEX_OFFSET_POSY = 1;\n"
    "const int VERTEX_OFFSET_POSZ = 2;\n"
    "const int VERTEX_OFFSET_NORX = 3;\n"
    "const int VERTEX_OFFSET_NORY = 4;\n"
    "const int VERTEX_OFFSET_NORZ = 5;\n"
    "const int VERTEX_OFFSET_U = 6;\n"
    "const int VERTEX_OFFSET_V = 7;\n"
    "const int VERTEX_OFFSET_TEXINDEX = 8;\n"
    "const int VERTEX_OFFSET_GLOWINDEX = 9;\n"
    "const int VERTEX_OFFSET_SPECINDEX = 10;\n"
    "const int VERTEX_OFFSET_NORMINDEX = 11;\n"
    "const int VERTEX_OFFSET_MODELINDEX = 12;\n"
    "const int VERTEX_OFFSET_INSTANCEINDEX = 13;\n"
    "const int VERTEX_OFFSET_U_LM = 14;\n"
    "const int VERTEX_OFFSET_V_LM = 15;\n"

    // Ray-Triangle Intersection (MÃ¶ller-Trumbore)
    "bool RayTriangle(vec3 origin, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out float t) {\n"
    "    vec3 edge1 = v1 - v0;\n"
    "    vec3 edge2 = v2 - v0;\n"
    "    vec3 h = cross(dir, edge2);\n"
    "    float a = dot(edge1, h);\n"
    "    if (abs(a) < 1e-6) return false;\n"

    "    float f = 1.0 / a;\n"
    "    vec3 s = origin - v0;\n"
    "    float u = f * dot(s, h);\n"
    "    if (u < 0.0 || u > 1.0) return false;\n"

    "    vec3 q = cross(s, edge1);\n"
    "    float v = f * dot(dir, q);\n"
    "    if (v < 0.0 || u + v > 1.0) return false;\n"

    "    t = f * dot(edge2, q);\n"
    "    return t > 0.001;\n"
    "}\n"

    // Compute barycentric coordinates in 2D UV space
    "vec3 Barycentric2D(vec2 p, vec2 v0, vec2 v1, vec2 v2) {\n"
    "    vec2 e0 = v1 - v0;\n"
    "    vec2 e1 = v2 - v0;\n"
    "    vec2 e2 = p - v0;\n"
    "    float d00 = dot(e0, e0);\n"
    "    float d01 = dot(e0, e1);\n"
    "    float d11 = dot(e1, e1);\n"
    "    float d20 = dot(e2, e0);\n"
    "    float d21 = dot(e2, e1);\n"
    "    float denom = d00 * d11 - d01 * d01;\n"
    "    if (abs(denom) < 1e-6) return vec3(1.0, 0.0, 0.0);\n"

    "    float u = (d11 * d20 - d01 * d21) / denom;\n"
    "    float v = (d00 * d21 - d01 * d20) / denom;\n"
    "    return vec3(1.0 - u - v, u, v);\n"
    "}\n"

    " void main() {\n"
         // Flattened global luxel index computed from X and global size\n"
    "    uint W = gl_NumWorkGroups.x * gl_WorkGroupSize.x;\n"
    "    uint x = gl_GlobalInvocationID.x;\n"
    "    uint y = gl_GlobalInvocationID.y;\n"
    "    uint luxelIdx = x + y * W;\n"
    "    if (luxelIdx >= totalLuxelCount) return;\n"

         // Find model for this luxel using lightmap offsets
    "    uint modelIdx = 0u;\n"
    "    uint luxelOffset = 0u;\n"
    "    bool found = false;\n"
    "    for (uint i = 0u; i + 1u < modelCount; ++i) {\n"
    "        if (luxelIdx < lightmapLuxelOffsets[i + 1u]) {\n"
    "            modelIdx = i;\n"
    "            luxelOffset = lightmapLuxelOffsets[i];\n"
    "            found = true;\n"
    "            break;\n"
    "        }\n"
    "    }\n"

    "    if (!found) {\n"
             // Out-of-range debug color (red)
    "        luxelData[luxelIdx * 4u + 0u] = 1.0;\n"
    "        luxelData[luxelIdx * 4u + 1u] = 0.0;\n"
    "        luxelData[luxelIdx * 4u + 2u] = 0.0;\n"
    "        luxelData[luxelIdx * 4u + 3u] = 1.0;\n"
    "        return;\n"
    "    }\n"

    "    uint localLuxelIdx = luxelIdx - luxelOffset;\n"

         // Per-model triangle base index
    "    uint baseTri = triangleOffsets[modelIdx];\n"
    "    uint triCount = triangleCounts[modelIdx];\n"
    "    uint triLuxelMetaBase = baseTri * 3u;\n" // each tri: [offset, u, v]

         // Find triangle within model for this local luxel
    "    uint triIdx = 0u;\n"
    "    for (uint i = 0u; i < triCount; ++i) {\n"
    "        uint o = triLuxelMetaBase + i * 3u;\n"
    "        uint triOff = triLuxelMetaData[o + 0u];\n"
    "        uint luxU = triLuxelMetaData[o + 1u];\n"
    "        uint luxV = triLuxelMetaData[o + 2u];\n"
    "        uint triCnt = luxU * luxV;\n"
    "        if (localLuxelIdx < triOff + triCnt) { triIdx = i; localLuxelIdx -= triOff; break; }\n"
    "    }\n"

         // Luxel grid coords
    "    uint luxU = triLuxelMetaData[triLuxelMetaBase + triIdx * 3u + 1u];\n"
    "    uint luxV = triLuxelMetaData[triLuxelMetaBase + triIdx * 3u + 2u];\n"
    "    uint luxelIdxU = localLuxelIdx % luxU;\n"
    "    uint luxelIdxV = localLuxelIdx / luxU;\n"
    "    float u = (float(luxelIdxU) + 0.5) / float(luxU);\n"
    "    float v = (float(luxelIdxV) + 0.5) / float(luxV);\n"

         // Vertex base offset for this model
    "    uint baseV = vertexOffsets[modelIdx];\n"
    "    uint baseTriIndex = baseTri * 3u;\n"
    "    uint t0 = tboMasterTable[baseTriIndex + triIdx * 3u + 0u];\n"
    "    uint t1 = tboMasterTable[baseTriIndex + triIdx * 3u + 1u];\n"
    "    uint t2 = tboMasterTable[baseTriIndex + triIdx * 3u + 2u];\n"
    "    uint v0Idx = baseV + t0;\n"
    "    uint v1Idx = baseV + t1;\n"
    "    uint v2Idx = baseV + t2;\n"

    "    vec3 v0 = vec3(vboMasterTable[v0Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSX],\n"
    "    vboMasterTable[v0Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSY],\n"
    "    vboMasterTable[v0Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSZ]);\n"
    "    vec3 v1 = vec3(vboMasterTable[v1Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSX],\n"
    "    vboMasterTable[v1Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSY],\n"
    "    vboMasterTable[v1Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSZ]);\n"
    "    vec3 v2 = vec3(vboMasterTable[v2Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSX],\n"
    "    vboMasterTable[v2Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSY],\n"
    "    vboMasterTable[v2Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSZ]);\n"

    "    vec3 n0 = vec3(vboMasterTable[v0Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_NORX],\n"
    "    vboMasterTable[v0Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_NORY],\n"
    "    vboMasterTable[v0Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_NORZ]);\n"
    "    vec3 n1 = vec3(vboMasterTable[v1Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_NORX],\n"
    "    vboMasterTable[v1Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_NORY],\n"
    "    vboMasterTable[v1Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_NORZ]);\n"
    "    vec3 n2 = vec3(vboMasterTable[v2Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_NORX],\n"
    "    vboMasterTable[v2Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_NORY],\n"
    "    vboMasterTable[v2Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_NORZ]);\n"

    "    vec2 uv0 = vec2(vboMasterTable[v0Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_U_LM],\n"
    "    vboMasterTable[v0Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_V_LM]);\n"
    "    vec2 uv1 = vec2(vboMasterTable[v1Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_U_LM],\n"
    "    vboMasterTable[v1Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_V_LM]);\n"
    "    vec2 uv2 = vec2(vboMasterTable[v2Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_U_LM],\n"
    "    vboMasterTable[v2Idx * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_V_LM]);\n"

    "    vec3 bary = Barycentric2D(vec2(u, v), uv0, uv1, uv2);\n"
    "    vec3 luxelPos = v0 * bary.x + v1 * bary.y + v2 * bary.z;\n"
    "    vec3 luxelNormal = normalize(n0 * bary.x + n1 * bary.y + n2 * bary.z);\n"

         // Use instance 0 as before (or apply per-instance logic if you have instance index)
    "    mat4 instanceMatrix = instanceMatrices[0];\n"
    "    vec4 worldPos = instanceMatrix * vec4(luxelPos, 1.0);\n"
    "    vec3 worldNormal = normalize((instanceMatrix * vec4(luxelNormal, 0.0)).xyz);\n"

    "    vec3 lighting = vec3(0.0);\n"
    "    for (uint i = 0u; i < MAX_VISIBLE_LIGHTS; ++i) {\n"
    "        uint lightIdx = i * uint(LIGHT_DATA_SIZE);\n"
    "        float intensity = lightInPVS[lightIdx + uint(LIGHT_DATA_OFFSET_INTENSITY)];\n"
    "        if (intensity < 0.05) continue;\n"

    "        vec3 lightPos = vec3(lightInPVS[lightIdx + uint(LIGHT_DATA_OFFSET_POSX)],\n"
    "        lightInPVS[lightIdx + uint(LIGHT_DATA_OFFSET_POSY)],\n"
    "        lightInPVS[lightIdx + uint(LIGHT_DATA_OFFSET_POSZ)]);\n"
    "        vec3 lightColor = vec3(lightInPVS[lightIdx + uint(LIGHT_DATA_OFFSET_R)],\n"
    "        lightInPVS[lightIdx + uint(LIGHT_DATA_OFFSET_G)],\n"
    "        lightInPVS[lightIdx + uint(LIGHT_DATA_OFFSET_B)]);\n"
    "        float range = lightInPVS[lightIdx + uint(LIGHT_DATA_OFFSET_RANGE)];\n"
    "        vec3 toLight = lightPos - worldPos.xyz;\n"
    "        float dist = length(toLight);\n"
    "        if (dist > range) continue;\n"

    "        vec3 lightDir = normalize(toLight);\n"
    "        float lambertian = max(dot(worldNormal, lightDir), 0.0);\n"
    "        if (lambertian < 0.25) continue;\n"

    "        bool occluded = false;\n"
    "        for (uint j = 0u; j < instanceCount; ++j) {\n"
    "            uint instModelIdx = uint(instances[j].modelIndex);\n"
    "            if (instModelIdx >= modelCount) continue;\n"

    "            mat4 instMatrix = instanceMatrices[j];\n"
    "            uint instBaseTri = triangleOffsets[instModelIdx];\n"
    "            uint instTriCount = triangleCounts[instModelIdx];\n"
    "            uint instTriBaseIndex = instBaseTri * 3u;\n"
    "            for (uint t = 0u; t < instTriCount; ++t) {\n"
    "                uint ti0 = tboMasterTable[instTriBaseIndex + t * 3u + 0u];\n"
    "                uint ti1 = tboMasterTable[instTriBaseIndex + t * 3u + 1u];\n"
    "                uint ti2 = tboMasterTable[instTriBaseIndex + t * 3u + 2u];\n"

                     // Add vertex base for that model
    "                uint t0vi = vertexOffsets[instModelIdx] + ti0;\n"
    "                uint t1vi = vertexOffsets[instModelIdx] + ti1;\n"
    "                uint t2vi = vertexOffsets[instModelIdx] + ti2;\n"
    "                vec3 tt0 = vec3(vboMasterTable[t0vi * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSX],\n"
    "                vboMasterTable[t0vi * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSY],\n"
    "                vboMasterTable[t0vi * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSZ]);\n"
    "                vec3 tt1 = vec3(vboMasterTable[t1vi * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSX],\n"
    "                vboMasterTable[t1vi * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSY],\n"
    "                vboMasterTable[t1vi * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSZ]);\n"
    "                vec3 tt2 = vec3(vboMasterTable[t2vi * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSX],\n"
    "                vboMasterTable[t2vi * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSY],\n"
    "                vboMasterTable[t2vi * VERTEX_ATTRIBUTES_COUNT + VERTEX_OFFSET_POSZ]);\n"
    "                vec4 wt0 = instMatrix * vec4(tt0, 1.0);\n"
    "                vec4 wt1 = instMatrix * vec4(tt1, 1.0);\n"
    "                vec4 wt2 = instMatrix * vec4(tt2, 1.0);\n"
    "                float tHit;\n"
    "                if (RayTriangle(worldPos.xyz, lightDir, wt0.xyz, wt1.xyz, wt2.xyz, tHit) && tHit < dist) { occluded = true; break; }\n"
    "            }\n"

    "            if (occluded) break;\n"
    "        }\n"

    "        if (!occluded) {\n"
    "            float attenuation = 1.0 / (1.0 + 0.1 * dist + 0.01 * dist * dist);\n"
    "            lighting += lightColor * intensity * lambertian * attenuation;\n"
    "        }\n"
    "    }\n"

    "    luxelData[luxelIdx * 4u + 0u] = lighting.r;\n"
    "    luxelData[luxelIdx * 4u + 1u] = lighting.g;\n"
    "    luxelData[luxelIdx * 4u + 2u] = lighting.b;\n"
    "    luxelData[luxelIdx * 4u + 3u] = 1.0;\n"
    " }\n";
