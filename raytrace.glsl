const char* rayTracingFragmentShader =
    "#version 450 core\n"
    "\n"
    "// --- Data Structures ---\n"
    "struct Ray {\n"
    "    vec3 origin;\n"
    "    vec3 dir;\n"
    "    vec3 invDir;\n"
    "};\n"
    "\n"
    "struct Triangle {\n"
    "    vec3 posA, posB, posC;\n"
    "    vec3 normA, normB, normC;\n"
    "    vec4 color;\n"
    "    vec2 uvA, uvB, uvC;\n"
    "    vec4 tanA, tanB, tanC;\n"
    "};\n"
    "\n"
    "struct TriangleHitInfo {\n"
    "    bool didHit;\n"
    "    float dst;\n"
    "    vec3 hitPoint;\n"
    "    vec3 normal;\n"
    "    vec4 tanA, tanB, tanC;\n"
    "    int triIndex;\n"
    "    int textureIndex;\n"
    "    vec2 uv;\n"
    "};\n"
    "\n"
    "struct Model {\n"
    "    int nodeOffset;\n"
    "    int triOffset;\n"
    "    mat4 worldToLocalMatrix;\n"
    "    mat4 localToWorldMatrix;\n"
    "};\n"
    "\n"
    "struct BVHNode {\n"
    "    vec3 boundsMin;\n"
    "    vec3 boundsMax;\n"
    "    int startIndex;\n"
    "    int triangleCount;\n"
    "};\n"
    "\n"
    "struct ModelHitInfo {\n"
    "    bool didHit;\n"
    "    vec3 normal;\n"
    "    vec3 hitPoint;\n"
    "    float dst;\n"
    "    vec2 uv;\n"
    "    int textureIndex;\n"
    "    vec4 tanA, tanB, tanC;\n"
    "};\n"
    "\n"
    "struct LightData {\n"
    "    vec4 color;\n"
    "    vec3 position;\n"
    "    float intensity;\n"
    "    float range;\n"
    "    vec3 direction;\n"
    "    float angle;\n"
    "};\n"
    "\n"
    "// --- Buffers ---\n"
    "layout(std430, binding = 0) buffer ModelBuffer {\n"
    "    Model ModelInfo[];\n"
    "};\n"
    "layout(std430, binding = 1) buffer TriangleBuffer {\n"
    "    Triangle Triangles[];\n"
    "};\n"
    "layout(std430, binding = 2) buffer NodeBuffer {\n"
    "    BVHNode Nodes[];\n"
    "};\n"
    "layout(std430, binding = 3) buffer LightBuffer {\n"
    "    LightData Lights[];\n"
    "};\n"
    "\n"
    "uniform int triangleCount;\n"
    "uniform int modelCount;\n"
    "uniform int lightsCount;\n"
    "\n"
    "// --- Textures ---\n"
    "layout(binding = 4) uniform sampler2DArray MainTexArray;\n"
    "layout(binding = 5) uniform sampler2DArray MainTexArrayNorm;\n"
    "layout(binding = 6) uniform sampler2DArray MainTexArraySpec;\n"
    "layout(binding = 7) uniform sampler2DArray MainTexArrayGlow;\n"
    "\n"
    "// --- Settings and Uniforms ---\n"
    "uniform int MaxBounceCount;\n"
    "uniform int shadowsEnabled;\n"
    "uniform int reflectionsEnabled;\n"
    "uniform float DefocusStrength;\n"
    "uniform float DivergeStrength;\n"
    "uniform vec3 ViewParams;\n"
    "uniform mat4 CamLocalToWorldMatrix;\n"
    "uniform vec3 CameraPosition;\n"
    "uniform int visMode;\n"
    "uniform float debugVisScale;\n"
    "\n"
    "// --- Input/Output ---\n"
    "in vec2 v_UV;\n"
    "out vec4 FragColor;\n"
    "\n"
    "// --- Constants ---\n"
    "const float PI = 3.14159265359;\n"
    "const float MAX_LIGHT_INTENSITY = 10.0;\n"
    "\n"
    "// --- Ray Intersection Functions ---\n"
    "TriangleHitInfo RayTriangle(Ray ray, Triangle tri) {\n"
    "    vec3 edgeAB = tri.posB - tri.posA;\n"
    "    vec3 edgeAC = tri.posC - tri.posA;\n"
    "    vec3 normalVector = cross(edgeAB, edgeAC);\n"
    "    vec3 ao = ray.origin - tri.posA;\n"
    "    vec3 dao = cross(ao, ray.dir);\n"
    "\n"
    "    float determinant = -dot(ray.dir, normalVector);\n"
    "    float invDet = 1.0 / determinant;\n"
    "\n"
    "    float dst = dot(ao, normalVector) * invDet;\n"
    "    float u = dot(edgeAC, dao) * invDet;\n"
    "    float v = -dot(edgeAB, dao) * invDet;\n"
    "    float w = 1.0 - u - v;\n"
    "\n"
    "    TriangleHitInfo hitInfo;\n"
    "    hitInfo.didHit = determinant >= 1E-8 && dst >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;\n"
    "    hitInfo.hitPoint = ray.origin + ray.dir * dst;\n"
    "    hitInfo.normal = normalize(tri.normA * w + tri.normB * u + tri.normC * v);\n"
    "    hitInfo.dst = dst;\n"
    "    hitInfo.uv = tri.uvA * w + tri.uvB * u + tri.uvC * v;\n"
    "    hitInfo.textureIndex = int(tri.color.r * 255.0);\n"
    "    hitInfo.tanA = tri.tanA;\n"
    "    hitInfo.tanB = tri.tanB;\n"
    "    hitInfo.tanC = tri.tanC;\n"
    "    return hitInfo;\n"
    "}\n"
    "\n"
    "float RayBoundingBoxDst(vec3 org, vec3 invDir, vec3 boxMin, vec3 boxMax) {\n"
    "    vec3 tMin = (boxMin - org) * invDir;\n"
    "    vec3 tMax = (boxMax - org) * invDir;\n"
    "    vec3 t1 = min(tMin, tMax);\n"
    "    vec3 t2 = max(tMin, tMax);\n"
    "    float tNear = max(max(t1.x, t1.y), t1.z);\n"
    "    float tFar = min(min(t2.x, t2.y), t2.z);\n"
    "\n"
    "    bool hit = tFar >= tNear && tFar > 0.0;\n"
    "    return hit ? (tNear > 0.0 ? tNear : 0.0) : 1.0 / 0.0;\n"
    "}\n"
    "\n"
    "TriangleHitInfo RayTriangleBVH(inout Ray ray, float rayLength, int nodeOffset, int triOffset) {\n"
    "    TriangleHitInfo result;\n"
    "    result.dst = rayLength;\n"
    "    result.triIndex = -1;\n"
    "    int stack[128];\n"
    "    int stackIndex = 0;\n"
    "    stack[stackIndex++] = nodeOffset;\n"
    "\n"
    "    while (stackIndex > 0) {\n"
    "        BVHNode node = Nodes[stack[--stackIndex]];\n"
    "        if (node.triangleCount > 0) {\n"
    "            for (int i = 0; i < node.triangleCount; i++) {\n"
    "                Triangle tri = Triangles[triOffset + node.startIndex + i];\n"
    "                TriangleHitInfo triHitInfo = RayTriangle(ray, tri);\n"
    "                if (triHitInfo.didHit && triHitInfo.dst < result.dst) {\n"
    "                    result = triHitInfo;\n"
    "                    result.triIndex = node.startIndex + i;\n"
    "                    result.tanA = tri.tanA;\n"
    "                    result.tanB = tri.tanB;\n"
    "                    result.tanC = tri.tanC;\n"
    "                }\n"
    "            }\n"
    "        } else {\n"
    "            int childIndexA = nodeOffset + node.startIndex;\n"
    "            int childIndexB = nodeOffset + node.startIndex + 1;\n"
    "            BVHNode childA = Nodes[childIndexA];\n"
    "            BVHNode childB = Nodes[childIndexB];\n"
    "            float dstA = RayBoundingBoxDst(ray.origin, ray.invDir, childA.boundsMin, childA.boundsMax);\n"
    "            float dstB = RayBoundingBoxDst(ray.origin, ray.invDir, childB.boundsMin, childB.boundsMax);\n"
    "\n"
    "            if (dstA <= dstB) {\n"
    "                if (dstB < result.dst) stack[stackIndex++] = childIndexB;\n"
    "                if (dstA < result.dst) stack[stackIndex++] = childIndexA;\n"
    "            } else {\n"
    "                if (dstA < result.dst) stack[stackIndex++] = childIndexA;\n"
    "                if (dstB < result.dst) stack[stackIndex++] = childIndexB;\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "    return result;\n"
    "}\n"
    "\n"
    "ModelHitInfo CalculateRayCollision(Ray worldRay) {\n"
    "    ModelHitInfo result;\n"
    "    result.dst = 1.0 / 0.0;\n"
    "    result.didHit = false;\n"
    "    Ray localRay;\n"
    "    for (int i = 0; i < modelCount; i++) {\n"
    "        Model model = ModelInfo[i];\n"
    "        vec4 localOrigin = model.worldToLocalMatrix * vec4(worldRay.origin, 1.0);\n"
    "        vec4 localDir = model.worldToLocalMatrix * vec4(worldRay.dir, 0.0);\n"
    "\n"
    "        localRay.origin = localOrigin.xyz;\n"
    "        localRay.dir = localDir.xyz;\n"
    "        localRay.invDir = 1.0 / localRay.dir;\n"
    "\n"
    "        TriangleHitInfo hit = RayTriangleBVH(localRay, result.dst, model.nodeOffset, model.triOffset);\n"
    "\n"
    "        if (hit.dst < result.dst) {\n"
    "            result.didHit = true;\n"
    "            result.dst = hit.dst;\n"
    "            vec4 normul = normalize(model.localToWorldMatrix * vec4(hit.normal, 0.0));\n"
    "            result.normal = normul.xyz;\n"
    "            result.hitPoint = worldRay.origin + worldRay.dir * hit.dst;\n"
    "            result.uv = hit.uv;\n"
    "            result.tanA = hit.tanA;\n"
    "            result.tanB = hit.tanB;\n"
    "            result.tanC = hit.tanC;\n"
    "            result.textureIndex = hit.textureIndex;\n"
    "        }\n"
    "    }\n"
    "    return result;\n"
    "}\n"
    "\n"
    "// --- Texture Sampling Functions ---\n"
    "vec3 SampleTextureArray(int index, vec2 uv) {\n"
    "    return texture(MainTexArray, vec3(uv, index)).rgb;\n"
    "}\n"
    "\n"
    "vec3 SampleTextureArrayNorm(int index, vec2 uv) {\n"
    "    vec3 norm = texture(MainTexArrayNorm, vec3(uv, index)).rgb;\n"
    "    norm = normalize(norm * 2.0 - 1.0);\n"
    "    return norm;\n"
    "}\n"
    "\n"
    "vec3 SampleTextureArraySpec(int index, vec2 uv) {\n"
    "    return texture(MainTexArraySpec, vec3(uv, index)).rgb;\n"
    "}\n"
    "\n"
    "vec3 SampleTextureArrayGlow(int index, vec2 uv) {\n"
    "    return texture(MainTexArrayGlow, vec3(uv, index)).rgb;\n"
    "}\n"
    "\n"
    "// --- Lighting Calculations ---\n"
    "vec3 GetPointLighting(vec3 pos, vec3 dir, vec3 norm, vec3 glow) {\n"
    "    vec3 result = vec3(0.0);\n"
    "    for (int i = 0; i < lightsCount; i++) {\n"
    "        LightData lit = Lights[i];\n"
    "        vec3 litdir = lit.position - pos;\n"
    "        float distance = length(litdir);\n"
    "        litdir = normalize(litdir);\n"
    "        if (distance > lit.range) continue;\n"
    "\n"
    "        float spotFalloff = 1.0;\n"
    "        if (lit.angle > 0.0) {\n"
    "            float spotdot = dot(lit.direction, litdir);\n"
    "            float cosAngle = cos(radians(lit.angle / 2.0));\n"
    "            if (spotdot < cosAngle) continue;\n"
    "\n"
    "            float cosOuterAngle = cos(radians(lit.angle / 2.0));\n"
    "            float cosInnerAngle = cos(radians(lit.angle * 0.8 / 2.0));\n"
    "            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);\n"
    "            if (spotFalloff <= 0.0) continue;\n"
    "        }\n"
    "\n"
    "        Ray ray;\n"
    "        ray.origin = pos;\n"
    "        ray.dir = normalize(lit.position - pos);\n"
    "        ray.invDir = 1.0 / ray.dir;\n"
    "        if (shadowsEnabled > 0 && lit.range > 1.5 && lit.intensity > 0.5) {\n"
    "            ModelHitInfo hitInfo = CalculateRayCollision(ray);\n"
    "            float shaddist = length(hitInfo.hitPoint - ray.origin);\n"
    "            if (hitInfo.didHit && shaddist < distance && shaddist > 0.001) continue;\n"
    "        }\n"
    "\n"
    "        float attenuation = (1.0 - (distance / lit.range)) * max(dot(norm, ray.dir), 0.0);\n"
    "        result += lit.color.rgb * lit.intensity * attenuation * spotFalloff * 0.15;\n"
    "    }\n"
    "    return max(result, glow);\n"
    "}\n"
    "\n"
    "// --- Ray Tracing Logic ---\n"
    "vec3 Trace(vec3 rayOrigin, vec3 rayDir) {\n"
    "    vec3 incomingLight = vec3(0.0);\n"
    "    vec3 specGlowHit = vec3(0.0);\n"
    "    Ray ray;\n"
    "    ray.origin = rayOrigin;\n"
    "    ray.dir = rayDir;\n"
    "    ray.invDir = 1.0 / rayDir;\n"
    "    ModelHitInfo hitInfo = CalculateRayCollision(ray);\n"
    "    vec3 texColor = vec3(0.0);\n"
    "\n"
    "    if (hitInfo.didHit) {\n"
    "        texColor = SampleTextureArray(hitInfo.textureIndex, hitInfo.uv);\n"
    "\n"
    "        vec3 normalMap = SampleTextureArrayNorm(hitInfo.textureIndex, hitInfo.uv);\n"
    "        vec3 normal = normalize(hitInfo.normal);\n"
    "        vec3 normScaled = normalMap.z * -5.0;\n"
    "        vec3 transformedNormal = normalize((normScaled * rayDir) + normal);\n"
    "\n"
    "        vec3 specCol = vec3(0.0);\n"
    "        if (reflectionsEnabled > 0) {\n"
    "            specCol = SampleTextureArraySpec(hitInfo.textureIndex, hitInfo.uv);\n"
    "            vec3 newRayDir = reflect(rayDir, transformedNormal);\n"
    "            float dotProduct = dot(transformedNormal, -rayDir);\n"
    "            if (dotProduct < max(max(specCol.r, specCol.g), specCol.b)) {\n"
    "                ray.dir = newRayDir;\n"
    "                ray.invDir = 1.0 / newRayDir;\n"
    "                ray.origin = hitInfo.hitPoint;\n"
    "                ModelHitInfo specHit = CalculateRayCollision(ray);\n"
    "                if (specHit.didHit) {\n"
    "                    specGlowHit = SampleTextureArrayGlow(specHit.textureIndex, specHit.uv);\n"
    "                    specCol *= SampleTextureArray(specHit.textureIndex, specHit.uv) *\n"
    "                               GetPointLighting(specHit.hitPoint, ray.dir, specHit.normal, specGlowHit);\n"
    "                    specCol *= 5.0;\n"
    "                }\n"
    "            }\n"
    "        }\n"
    "\n"
    "        vec3 hitGlow = SampleTextureArrayGlow(hitInfo.textureIndex, hitInfo.uv);\n"
    "        vec3 gather = GetPointLighting(hitInfo.hitPoint, rayDir, transformedNormal, hitGlow);\n"
    "        gather += specCol;\n"
    "        incomingLight += gather;\n"
    "        return texColor * pow(incomingLight, vec3(2.5)) * 12.2;\n"
    "    }\n"
    "\n"
    "    return vec3(0.0);\n"
    "}\n"
    "\n"
    "// --- Main Fragment Shader ---\n"
    "void main() {\n"
    "    vec3 focusPointLocal = vec3(v_UV - 0.5, 1.0) * ViewParams;\n"
    "    vec3 focusPoint = (CamLocalToWorldMatrix * vec4(focusPointLocal, 1.0)).xyz;\n"
    "    vec3 rayOrigin = CameraPosition;\n"
    "    vec3 rayDir = normalize(focusPoint - rayOrigin);\n"
    "    vec3 color = Trace(rayOrigin, rayDir);\n"
    "    FragColor = vec4(color, 1.0);\n"
    "}\n";
