const char *computeShadowShader =
    "#version 450 core\n"
    "layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;\n"

    "layout(rgba32f, binding = 1) readonly uniform image2D inputWorldPos;\n"
    "layout(r8, binding = 2) uniform image2D outputShadowStencil;\n"
    "layout(std430, binding = 19) buffer LightIndices { float lightInPVS[]; };\n"

    "uniform vec2 uScreenSize;\n"
    "uniform mat4 uViewProjMatrix;\n"
    "uniform float uShadowBias = 0.01;\n"
    "uniform float uMaxRaySteps = 32.0;\n"
    "uniform float uStepSize = 0.1;\n"
    "uniform float playerPosX = 0.0;\n"
    "uniform float playerPosY = 0.0;\n"
    "uniform float playerPosZ = 0.0;\n"

    "uint packShadowBits(uint bits[32]) {\n"
    "    uint result = 0;\n"
    "    for (int i = 0; i < 32; ++i) result |= (bits[i] & 1u) << i;\n"
    "    return result;\n"
    "}\n"

    "bool traceShadowRay(vec3 startPos, vec3 lightPos, float maxDist, ivec2 startPixel, vec3 camPos) {\n"
    "    float startDepth = length(startPos - camPos);\n"
    "    vec3 toLight = lightPos - startPos;\n"
    "    float dist = length(toLight);\n"
    "    if (dist <= 0.001) return false;\n"

    "    vec4 lightProj = uViewProjMatrix * vec4(lightPos, 1.0);\n"
    "    lightProj /= lightProj.w;\n"
    "    vec2 lightUV = lightProj.xy * 0.5 + 0.5;\n"
//     "    if (lightUV.x < 0.0 || lightUV.x > 1.0 || lightUV.y < 0.0 || lightUV.y > 1.0) return false;\n"

    "    vec2 lightPixel = lightUV * uScreenSize;\n"
    "    vec2 rayDir = lightPixel - vec2(startPixel);\n"
    "    float pixelDist = length(rayDir);\n"
    "    if (pixelDist < 1.0) return false;\n"

    "    rayDir = normalize(rayDir);\n"
    "    int maxSteps = int(min(pixelDist, uMaxRaySteps));\n"
    "    float t = 1.0; // Start one pixel away to avoid self-occlusion\n"
    "    vec2 rayPos = vec2(startPixel) + rayDir * t;\n"
    "    for (int i = 0; i < maxSteps && t < pixelDist; ++i) {\n"
    "        vec3 worldPos = imageLoad(inputWorldPos, ivec2(rayPos)).xyz;\n"
    "        if (length(worldPos - lightPos) < 0.001) {\n"
    "            t++;\n"
    "            rayPos = vec2(startPixel) + rayDir * t;\n"
    "            continue;\n"
    "        }\n"

    "        float depthToWorld = length(worldPos - camPos);\n"
    "        if (depthToWorld > (startDepth + uShadowBias)) return true; // Occluder found\n"

    "        t++;\n"
    "        rayPos = vec2(startPixel) + rayDir * t;\n"
    "    }\n"
    "    return false;\n"
    "}\n"

    "void main() {\n"
    "    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);\n"
    "    if (pixel.x >= int(uScreenSize.x) || pixel.y >= int(uScreenSize.y)) return;\n"
        
    "    vec4 worldPosPack = imageLoad(inputWorldPos, pixel);\n"
    "    vec3 worldPos = worldPosPack.xyz;\n"
    "    uint shadowBits[32];\n"
    "    vec3 playerPos = vec3(playerPosX,playerPosY,playerPosZ);\n"
    "    for (int i = 0; i < 32; ++i) {\n"
    "        shadowBits[i] = 0;\n"
    "        uint lightIdx = i * 12;\n" // LIGHT_DATA_SIZE
            
    "        float range = lightInPVS[lightIdx + 4];\n"
    "        vec3 lightPos = vec3(lightInPVS[lightIdx + 0], lightInPVS[lightIdx + 1], lightInPVS[lightIdx + 2]);\n"
    "        vec3 toLight = lightPos - worldPos;\n"
    "        float dist = length(toLight);\n"
    "        if (dist > range) continue;\n"
            
    "        vec3 lightDir = normalize(toLight);\n"
    "        float spotAng = lightInPVS[lightIdx + 5];\n"
    "        float spotFalloff = 1.0;\n"
    "        if (spotAng > 0.0) {\n"
    "            vec3 spotDir = vec3(lightInPVS[lightIdx + 6], lightInPVS[lightIdx + 7], lightInPVS[lightIdx + 8]);\n"
    "            float spotdot = dot(spotDir, -lightDir);\n"
    "            float cosAngle = cos(radians(spotAng / 2.0));\n"
    "            if (spotdot < cosAngle) continue;\n"
    "            float cosOuterAngle = cos(radians(spotAng / 2.0));\n"
    "            float cosInnerAngle = cos(radians(spotAng * 0.8 / 2.0));\n"
    "            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);\n"
    "            if (spotFalloff <= 0.0) continue;\n"
    "        }\n"
            
    "        if (traceShadowRay(worldPos, lightPos, range, pixel, playerPos)) shadowBits[i] = 1;\n"
    "    }\n"
        
    "    imageStore(outputShadowStencil, pixel, vec4(packShadowBits(shadowBits) / 255.0));\n"
    "}\n";
