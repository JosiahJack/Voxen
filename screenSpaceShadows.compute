const char *computeShadowShader =
    "#version 450 core\n"
    "layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;\n"

    "layout(rgba32f, binding = 1) readonly uniform image2D inputWorldPos;\n"
    "layout(r8, binding = 2) uniform image2D outputShadowStencil;\n"
    "layout(std430, binding = 19) buffer LightIndices { float lightInPVS[]; };\n"

    "uniform vec2 uScreenSize;\n"
    "uniform mat4 projection;\n"
    "uniform mat4 matrix;\n"
    "uniform mat4 view;\n"
    "uniform float uShadowBias = 0.001;\n"
    "uniform float uMaxRaySteps = 16.0;\n"
    "uniform float uStepSize = 0.02;\n"
    "uniform float playerPosX = 0.0;\n"
    "uniform float playerPosY = 0.0;\n"
    "uniform float playerPosZ = 0.0;\n"

    "uint packShadowBits(uint bits[32]) {\n"
    "    uint result = 0;\n"
    "    for (int i = 0; i < 32; ++i) result |= (bits[i] & 1u) << i;\n"
    "    return result;\n"
    "}\n"

    "bool traceShadowRay(vec3 startPos, vec3 lightPos, float maxDist, ivec2 startPixel) {\n"
    "    vec3 toLight = lightPos - startPos;\n"
    "    float totalDist = length(toLight);\n"
    "    if (totalDist > maxDist || totalDist <= 0.001) return false;\n"
    "    vec3 rayPos = vec3(view * vec4(startPos, 1.0));\n"
    "    vec3 lightViewPos = vec3(view * vec4(lightPos, 1.0));\n"
    "    vec3 rayDir = normalize(lightViewPos - rayPos);\n"
    "    float stepLength = uStepSize / float(uMaxRaySteps);\n"
    "    vec3 rayStep = rayDir * stepLength;\n"
    "    float tolerance = 0.01;\n"
    "    for (int i = 0; i < int(uMaxRaySteps); ++i) {\n"
    "        rayPos += rayStep;\n"
    "        vec4 projPos = projection * vec4(rayPos, 1.0);\n"
    "        projPos /= projPos.w;\n"
    "        vec2 uv = projPos.xy * 0.5 + 0.5;\n"
    "        if (uv.x < 0.0) uv.x = 0.0;\n"
    "        if (uv.x > 1.0) uv.x = 1.0;\n"
    "        if (uv.y < 0.0) uv.y = 0.0;\n"
    "        if (uv.y > 1.0) uv.y = 1.0;\n"
    "        ivec2 pixel = ivec2(uv * uScreenSize);\n"
    "        if (pixel.x < 0 || pixel.x >= int(uScreenSize.x) || pixel.y < 0 || pixel.y >= int(uScreenSize.y)) continue;\n"
    "        vec3 worldPos = imageLoad(inputWorldPos, pixel).xyz;\n"
    "        if (length(worldPos) < 0.001) continue;\n"
    "        vec3 viewPos = vec3(view * matrix * vec4(worldPos, 1.0));\n"
    "        float depthDelta = rayPos.z - viewPos.z;\n"
    "        if (abs(depthDelta - tolerance) < tolerance && depthDelta > uShadowBias) {\n"
    "            return true;\n"
    "        }\n"
    "    }\n"
    "    return false;\n"
    "}\n"

    "void main() {\n"
    "    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);\n"
    "    if (pixel.x >= int(uScreenSize.x) || pixel.y >= int(uScreenSize.y)) return;\n"
        
    "    vec4 worldPosPack = imageLoad(inputWorldPos, pixel);\n"
    "    vec3 worldPos = worldPosPack.xyz;\n"
    "    uint shadowBits[32];\n"
    "    vec3 playerPos = vec3(playerPosX,playerPosY,playerPosZ);\n"
    "    for (int i = 0; i < 32; ++i) {\n"
    "        shadowBits[i] = 0;\n"
    "        uint lightIdx = i * 12;\n" // LIGHT_DATA_SIZE
            
    "        float range = lightInPVS[lightIdx + 4];\n"
    "        vec3 lightPos = vec3(lightInPVS[lightIdx + 0], lightInPVS[lightIdx + 1], lightInPVS[lightIdx + 2]);\n"
    "        vec3 toLight = lightPos - worldPos;\n"
    "        float dist = length(toLight);\n"
    "        if (dist > range) continue;\n"
            
    "        vec3 lightDir = normalize(toLight);\n"
    "        float spotAng = lightInPVS[lightIdx + 5];\n"
    "        float spotFalloff = 1.0;\n"
    "        if (spotAng > 0.0) {\n"
    "            vec3 spotDir = vec3(lightInPVS[lightIdx + 6], lightInPVS[lightIdx + 7], lightInPVS[lightIdx + 8]);\n"
    "            float spotdot = dot(spotDir, -lightDir);\n"
    "            float cosAngle = cos(radians(spotAng / 2.0));\n"
    "            if (spotdot < cosAngle) continue;\n"
    "            float cosOuterAngle = cos(radians(spotAng / 2.0));\n"
    "            float cosInnerAngle = cos(radians(spotAng * 0.8 / 2.0));\n"
    "            spotFalloff = smoothstep(cosOuterAngle, cosInnerAngle, spotdot);\n"
    "            if (spotFalloff <= 0.0) continue;\n"
    "        }\n"
            
    "        if (traceShadowRay(worldPos, lightPos, range, pixel)) shadowBits[i] = 1;\n" // Light can see the point
    "    }\n"
        
    "    imageStore(outputShadowStencil, pixel, vec4(packShadowBits(shadowBits) / 255.0));\n"
    "}\n";
