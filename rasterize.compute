const char *rasterize_computeShader =
    "#version 450 core\n"
    "layout(local_size_x = 8, local_size_y = 8) in;\n"
    "\n"
    "layout(std430, binding = 0) buffer VertexBuffer {\n"
    "    float vertices[];\n"
    "};\n"
    "\n"
    "layout(rgba8, binding = 1) uniform image2D outputImage;\n"
    "\n"
    "layout(std430, binding = 2) buffer ColorBuffer {\n"
    "    float colors[];\n"
    "};\n"
    "\n"
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"
    "uniform uint textureOffsets[3];\n"
    "uniform ivec2 textureSizes[3];\n"
    "\n"
    "void main() {\n"
    "    uvec2 pixel = gl_GlobalInvocationID.xy;\n"
    "    vec2 p = vec2(float(pixel.x) + 0.5, float(pixel.y) + 0.5);\n"
    "    if (p.x >= float(screenWidth) || p.y >= float(screenHeight)) return;\n"
    "    if (p.x < 0 || p.y < 0) return;\n"
    "\n"
    "    uint hit = 99;\n"
    "    vec2 uv = vec2(0.0); // Interpolated UV coordinates\n"
    "    float texIndex = 0.0; // Texture index for the triangle\n"
    "\n"
    "    for (uint tri = 0; tri < 4; tri++) {\n"
    "        uint baseIdx = tri * 18;\n"
    "        vec2 p0 = vec2(vertices[baseIdx + 0], vertices[baseIdx + 1]);\n"
    "        vec2 p1 = vec2(vertices[baseIdx + 6], vertices[baseIdx + 7]);\n"
    "        vec2 p2 = vec2(vertices[baseIdx + 12], vertices[baseIdx + 13]);\n"
    "        vec2 uv0 = vec2(vertices[baseIdx + 3], vertices[baseIdx + 4]);\n"
    "        vec2 uv1 = vec2(vertices[baseIdx + 9], vertices[baseIdx + 10]);\n"
    "        vec2 uv2 = vec2(vertices[baseIdx + 15], vertices[baseIdx + 16]);\n"
    "\n"
    "        // Bounding box check\n"
    "        float minX = min(min(p0.x, p1.x), p2.x);\n"
    "        float maxX = max(max(p0.x, p1.x), p2.x);\n"
    "        float minY = min(min(p0.y, p1.y), p2.y);\n"
    "        float maxY = max(max(p0.y, p1.y), p2.y);\n"
    "        if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) continue;\n"
    "\n"
    "        // Point-in-triangle test (CCW winding)\n"
    "        vec2 e0 = p1 - p0;\n"
    "        vec2 e1 = p2 - p1;\n"
    "        vec2 e2 = p0 - p2;\n"
    "        vec2 p0p = p - p0;\n"
    "        vec2 p1p = p - p1;\n"
    "        vec2 p2p = p - p2;\n"
    "\n"
    "        float c0 = e0.x * p0p.y - e0.y * p0p.x;\n"  // Cross product for edge p0->p1\n"
    "        float c1 = e1.x * p1p.y - e1.y * p1p.x;\n"  // Cross product for edge p1->p2\n"
    "        float c2 = e2.x * p2p.y - e2.y * p2p.x;\n"  // Cross product for edge p2->p0\n"
    "\n"
    "        if (c0 >= 0.0 && c1 >= 0.0 && c2 >= 0.0) {\n"  // All positive for CCW\n"
    "            // Barycentric coordinates\n"
    "            float area = c0 + c1 + c2; // Total area (twice the actual area)\n"
    "            if (area == 0.0) continue; // Avoid division by zero\n"
    "\n"
    "            float w0 = c1 / area; // Weight for p2\n"
    "            float w1 = c2 / area; // Weight for p0\n"
    "            float w2 = c0 / area; // Weight for p1\n"
    "\n"
    "            // Interpolate UV coordinates\n"
    "            uv = w0 * uv0 + w1 * uv1 + w2 * uv2;\n"
    "            hit = tri;\n"
    "            break;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    if (hit < 99) {\n"
    "        int index = int(texIndex);\n"
    "        ivec2 texSize = textureSizes[index];\n"
    "        vec2 uvClamped = clamp(uv, 0.0, 1.0);\n"
    "        int x = int(uvClamped.x * float(texSize.x));\n"
    "        int y = int(uvClamped.y * float(texSize.y));\n"
    "        int pixelIndex = int(textureOffsets[index]) + (y * texSize.x + x) * 4;\n"
    "        vec4 color = vec4(colors[pixelIndex], colors[pixelIndex + 1], colors[pixelIndex + 2], colors[pixelIndex + 3]);\n"
    "        imageStore(outputImage, ivec2(pixel), color);\n"
    "    } else {\n"
    "        imageStore(outputImage, ivec2(pixel), vec4(0.0, 0.0, 0.0, 1.0));\n"
    "    }\n"
    "}\n";
