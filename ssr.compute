// ssr.compute
// Compute shader for processing 
// ssr.compute
// ssr.compute
const char* ssr_computeShader =
    "#version 450 core\n"
    "layout(local_size_x = 32, local_size_y = 32) in;\n"

    "layout(rgba8,   binding = 0)  readonly uniform image2D inputImage;\n"
    "layout(rgba32f, binding = 1)  readonly uniform image2D inputWorldPos;\n"
    "layout(rgba32f, binding = 2)  readonly uniform image2D inputNormals;\n"
    "layout(rgba32f, binding = 4)  writeonly uniform image2D outputImage;\n"
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"
    "uniform mat4 viewProjection;\n"
    "uniform float cam_x;\n"
    "uniform float cam_y;\n"
    "uniform float cam_z;\n"
    "const int   maxSteps    = 1024;\n"
    "const float stepSize    = 0.01;\n"
    "const float maxDistance = 20.48;\n"

    "vec4 unpackColor32(uint color) {\n"
    "    return vec4(float((color >> 24) & 0xFF) / 255.0,\n"
    "                float((color >> 16) & 0xFF) / 255.0,\n"
    "                float((color >>  8) & 0xFF) / 255.0,\n"
    "                float((color      ) & 0xFF) / 255.0);\n"
    "}\n"

    "void main() {\n"
    "    uvec2 pixel = gl_GlobalInvocationID.xy;\n"
    "    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;\n"

    "    vec4 worldPosPack = imageLoad(inputWorldPos, ivec2(pixel));\n"
    "    vec3 worldPos = worldPosPack.xyz;\n"
    "    vec4 color = imageLoad(inputImage, ivec2(pixel));\n"
    "    vec4 normalPack = imageLoad(inputNormals, ivec2(pixel));\n"
    "    vec2 normalXY = unpackHalf2x16(floatBitsToInt(normalPack.r));\n"
    "    vec2 normalZ0 = unpackHalf2x16(floatBitsToInt(normalPack.g));\n"
    "    vec3 normal = normalize(vec3(normalXY.x, normalXY.y, normalZ0.x));\n"
    "    vec4 specColor = unpackColor32(floatBitsToUint(normalPack.a));\n"
    "    vec3 camPos = vec3(cam_x, cam_y, cam_z);\n"
    "    vec3 viewDir = normalize(worldPos - camPos);\n"
    "    vec3 reflectDir = normalize(reflect(viewDir, normal));\n"
    "    if (any(isnan(reflectDir)) || any(isinf(reflectDir))) { imageStore(outputImage, ivec2(pixel), color); return; }\n"

    "    vec2 hitUV = vec2(0.0);\n"
    "    bool hit = false;\n"
    "    vec3 marchPos = worldPos + normal * 0.01;\n"
    "    float traveled = 0.0;\n"
    "    for (int i = 0; i < maxSteps; ++i) {\n"
    "        marchPos += reflectDir * stepSize;\n"
    "        traveled += stepSize;\n"
    "        if (traveled > maxDistance) break;\n"

    "        vec4 clipPos = viewProjection * vec4(marchPos, 1.0);\n"
    "        if (clipPos.w <= 0.0) break;\n"

    "        vec2 ndc = (clipPos.xy / clipPos.w);\n"
    "        vec2 uv = ndc * 0.5 + 0.5;\n"
    "        if (uv.x <= 0.0 || uv.x >= 1.0 || uv.y <= 0.0 || uv.y >= 1.0) break;\n"

    "        ivec2 samplePixel = ivec2(floor(uv * vec2(screenWidth, screenHeight)));\n"
    "        samplePixel = clamp(samplePixel, ivec2(0), ivec2(int(screenWidth)-1, int(screenHeight)-1));\n"
    "        vec4 sampledWorldPosPack = imageLoad(inputWorldPos, samplePixel);\n"
    "        vec3 sampledWorldPos = sampledWorldPosPack.xyz;\n"
    "        float distToSampled = length(marchPos - sampledWorldPos);\n"
    "        if (distToSampled < 0.16) { hitUV = uv; hit = true; break; }\n"
    "    }\n"

    "    if (hit) {\n"
    "        imageStore(outputImage, ivec2(pixel), vec4(1.0, 0.0, 0.0, 1.0));\n"
    "    } else {\n"
    "        imageStore(outputImage, ivec2(pixel), color);\n"
    "    }\n"
    "}\n";
