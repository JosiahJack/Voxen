// ssr.compute
// Compute shader for processing 
const char* ssr_computeShader =
    "#version 450 core\n"
    "layout(local_size_x = 32, local_size_y = 32) in;\n"

    "layout(rgba8,   binding = 0)  readonly uniform image2D inputImage;\n"
    "layout(rgba32f, binding = 1)  readonly uniform image2D inputWorldPos;\n"
    "layout(rgba32f, binding = 2)  readonly uniform image2D inputNormals;\n"
    "layout(rgba32f, binding = 4)  writeonly uniform image2D outputImage;\n"
    "layout(std430, binding = 13) buffer BlueNoise { float blueNoiseColors[]; };\n"
    "uniform uint screenWidth;\n"
    "uniform uint screenHeight;\n"
    "uniform mat4 viewProjection;\n"
    "uniform float cam_x;\n"
    "uniform float cam_y;\n"
    "uniform float cam_z;\n"
    "uniform int   maxSteps;\n"
    "uniform float stepSize;\n"
    "uniform float maxDistance;\n"

    "vec4 unpackColor32(uint color) {\n"
    "    return vec4(float((color >> 24) & 0xFF) / 255.0,\n"  // r
    "                float((color >> 16) & 0xFF) / 255.0,\n"  // g
    "                float((color >>  8) & 0xFF) / 255.0,\n"  // b
    "                float((color      ) & 0xFF) / 255.0);\n" // a
    "}\n"

    "void main() {\n"
    "    uvec2 pixel = gl_GlobalInvocationID.xy;\n"
    "    if (pixel.x >= screenWidth || pixel.y >= screenHeight) return;\n"

    "    vec4 worldPosPack = imageLoad(inputWorldPos, ivec2(pixel));\n"
    "    vec3 worldPos = worldPosPack.xyz;\n"
    "    vec4 baseColor = imageLoad(inputImage, ivec2(pixel));\n"
    "    vec4 normalPack = imageLoad(inputNormals, ivec2(pixel));\n"
    "    vec2 normalXY = unpackHalf2x16(floatBitsToInt(normalPack.r));\n"
    "    vec2 normalZ0 = unpackHalf2x16(floatBitsToInt(normalPack.g));\n"
    "    vec3 normal = normalize(vec3(normalXY.x, normalXY.y, normalZ0.x));\n"
    "    vec4 specColor = unpackColor32(floatBitsToUint(normalPack.a));\n"
    "    vec3 camPos = vec3(cam_x, cam_y, cam_z);\n"
    "    vec3 viewDir = normalize(worldPos - camPos);\n"
    "    vec3 reflectDir = normalize(reflect(viewDir, normal));\n"
    "    if (any(isnan(reflectDir)) || any(isinf(reflectDir))) {\n"
    "        imageStore(outputImage, ivec2(pixel), baseColor);\n"
    "        return;\n"
    "    }\n"

    "    vec2 hitUV = vec2(0.0);\n"
    "    bool hit = false;\n"
    "    vec3 marchPos = worldPos + normal * 0.01;\n"
    "    float traveled = 0.0;\n"
    "    for (int i = 0; i < maxSteps; ++i) {\n"
    "        marchPos += reflectDir * stepSize;\n"
    "        traveled += stepSize;\n"
    "        if (traveled > maxDistance) break;\n"

    "        vec4 clipPos = viewProjection * vec4(marchPos, 1.0);\n"
    "        if (clipPos.w <= 0.0) break;\n"

    "        vec2 ndc = clipPos.xy / clipPos.w;\n"
    "        vec2 uv = ndc * 0.5 + 0.5;\n"
    "        if (uv.x <= 0.0 || uv.x >= 1.0 || uv.y <= 0.0 || uv.y >= 1.0) break;\n"

    "        ivec2 samplePixel = ivec2(floor(uv * vec2(screenWidth, screenHeight)));\n"
    "        samplePixel = clamp(samplePixel, ivec2(0), ivec2(int(screenWidth)-1, int(screenHeight)-1));\n"
    "        vec4 sampledWorldPosPack = imageLoad(inputWorldPos, samplePixel);\n"
    "        vec3 sampledWorldPos = sampledWorldPosPack.xyz;\n"
    "        float distToSampled = length(marchPos - sampledWorldPos);\n"
    "        if (distToSampled < 0.16) { hitUV = uv; hit = true; break; }\n"
    "    }\n"

    "    if (hit) {\n"
    "        ivec2 hitPixel = ivec2(hitUV * vec2(screenWidth, screenHeight));\n"
    "        hitPixel = clamp(hitPixel, ivec2(0), ivec2(int(screenWidth)-1, int(screenHeight)-1));\n"
    "        vec4 reflectionColor = imageLoad(inputImage, hitPixel);\n"
    "        vec3 combined = mix(baseColor.rgb, reflectionColor.rgb, specColor.rgb);\n"

    // Dither
    "        int blueNoiseTextureWidth = 64;\n"
    "        int pixelIndex = int(((int(hitUV.y) % blueNoiseTextureWidth) * blueNoiseTextureWidth + (int(hitUV.x) % blueNoiseTextureWidth))) * 3;\n" // Calculate 1D index.  * 4 for four rgba values.
    "        vec4 bluenoise = vec4(blueNoiseColors[pixelIndex], blueNoiseColors[pixelIndex + 1], blueNoiseColors[pixelIndex + 2], 1.0);\n"
    "        combined += ((bluenoise.rgb * 2.0/255.0) - (1.0/255.0));\n"

    "        imageStore(outputImage, ivec2(pixel), vec4(combined, 1.0));\n"
    "    } else {\n"
    "        imageStore(outputImage, ivec2(pixel), baseColor);\n"
    "    }\n"
    "}\n";
